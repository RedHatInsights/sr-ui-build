{"version":3,"file":"8091.7a65b1dc.js","mappings":"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","sources":["webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/nodes/Node.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/visit.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/doc/directives.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/doc/anchors.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/nodes/Alias.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/nodes/toJS.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/nodes/Scalar.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/doc/createNode.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/nodes/Collection.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/stringify/stringifyComment.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/stringify/foldFlowLines.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/stringify/stringifyString.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/stringify/stringify.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/log.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/nodes/addPairToJSMap.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/nodes/Pair.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/stringify/stringifyPair.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/stringify/stringifyCollection.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/nodes/YAMLMap.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/schema/common/map.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/nodes/YAMLSeq.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/schema/common/seq.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/schema/common/string.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/schema/common/null.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/schema/core/bool.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/stringify/stringifyNumber.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/schema/core/float.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/schema/core/int.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/schema/core/schema.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/schema/json/schema.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/schema/yaml-1.1/float.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/schema/yaml-1.1/int.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/schema/yaml-1.1/set.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/schema/tags.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/schema/Schema.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/doc/applyReviver.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/doc/Document.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/stringify/stringifyDocument.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/errors.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/compose/resolve-props.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/compose/util-contains-newline.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/compose/util-flow-indent-check.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/compose/util-map-includes.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/compose/resolve-block-map.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/compose/resolve-end.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/compose/resolve-flow-collection.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/compose/compose-collection.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/compose/resolve-block-seq.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/compose/resolve-block-scalar.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/compose/compose-scalar.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/compose/compose-node.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/compose/composer.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/compose/compose-doc.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/parse/cst-scalar.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/parse/cst-stringify.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/parse/cst-visit.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/parse/cst.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/parse/lexer.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/parse/line-counter.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/parse/parser.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/dist/public-api.js","webpack://@apicurio/registry-ui/./node_modules/yaml/browser/index.js"],"sourcesContent":["const ALIAS = Symbol.for('yaml.alias');\nconst DOC = Symbol.for('yaml.document');\nconst MAP = Symbol.for('yaml.map');\nconst PAIR = Symbol.for('yaml.pair');\nconst SCALAR = Symbol.for('yaml.scalar');\nconst SEQ = Symbol.for('yaml.seq');\nconst NODE_TYPE = Symbol.for('yaml.node.type');\nconst isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;\nconst isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;\nconst isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;\nconst isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;\nconst isScalar = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR;\nconst isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;\nfunction isCollection(node) {\n    if (node && typeof node === 'object')\n        switch (node[NODE_TYPE]) {\n            case MAP:\n            case SEQ:\n                return true;\n        }\n    return false;\n}\nfunction isNode(node) {\n    if (node && typeof node === 'object')\n        switch (node[NODE_TYPE]) {\n            case ALIAS:\n            case MAP:\n            case SCALAR:\n            case SEQ:\n                return true;\n        }\n    return false;\n}\nconst hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;\nclass NodeBase {\n    constructor(type) {\n        Object.defineProperty(this, NODE_TYPE, { value: type });\n    }\n    /** Create a copy of this node.  */\n    clone() {\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n}\n\nexport { ALIAS, DOC, MAP, NODE_TYPE, NodeBase, PAIR, SCALAR, SEQ, hasAnchor, isAlias, isCollection, isDocument, isMap, isNode, isPair, isScalar, isSeq };\n","import { isDocument, isNode, isPair, isCollection, isMap, isSeq, isScalar, isAlias } from './nodes/Node.js';\n\nconst BREAK = Symbol('break visit');\nconst SKIP = Symbol('skip children');\nconst REMOVE = Symbol('remove node');\n/**\n * Apply a visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nfunction visit(node, visitor) {\n    const visitor_ = initVisitor(visitor);\n    if (isDocument(node)) {\n        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));\n        if (cd === REMOVE)\n            node.contents = null;\n    }\n    else\n        visit_(null, node, visitor_, Object.freeze([]));\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisit.BREAK = BREAK;\n/** Do not visit the children of the current node */\nvisit.SKIP = SKIP;\n/** Remove the current node */\nvisit.REMOVE = REMOVE;\nfunction visit_(key, node, visitor, path) {\n    const ctrl = callVisitor(key, node, visitor, path);\n    if (isNode(ctrl) || isPair(ctrl)) {\n        replaceNode(key, path, ctrl);\n        return visit_(key, ctrl, visitor, path);\n    }\n    if (typeof ctrl !== 'symbol') {\n        if (isCollection(node)) {\n            path = Object.freeze(path.concat(node));\n            for (let i = 0; i < node.items.length; ++i) {\n                const ci = visit_(i, node.items[i], visitor, path);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    node.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n        }\n        else if (isPair(node)) {\n            path = Object.freeze(path.concat(node));\n            const ck = visit_('key', node.key, visitor, path);\n            if (ck === BREAK)\n                return BREAK;\n            else if (ck === REMOVE)\n                node.key = null;\n            const cv = visit_('value', node.value, visitor, path);\n            if (cv === BREAK)\n                return BREAK;\n            else if (cv === REMOVE)\n                node.value = null;\n        }\n    }\n    return ctrl;\n}\n/**\n * Apply an async visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `Promise`: Must resolve to one of the following values\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nasync function visitAsync(node, visitor) {\n    const visitor_ = initVisitor(visitor);\n    if (isDocument(node)) {\n        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));\n        if (cd === REMOVE)\n            node.contents = null;\n    }\n    else\n        await visitAsync_(null, node, visitor_, Object.freeze([]));\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisitAsync.BREAK = BREAK;\n/** Do not visit the children of the current node */\nvisitAsync.SKIP = SKIP;\n/** Remove the current node */\nvisitAsync.REMOVE = REMOVE;\nasync function visitAsync_(key, node, visitor, path) {\n    const ctrl = await callVisitor(key, node, visitor, path);\n    if (isNode(ctrl) || isPair(ctrl)) {\n        replaceNode(key, path, ctrl);\n        return visitAsync_(key, ctrl, visitor, path);\n    }\n    if (typeof ctrl !== 'symbol') {\n        if (isCollection(node)) {\n            path = Object.freeze(path.concat(node));\n            for (let i = 0; i < node.items.length; ++i) {\n                const ci = await visitAsync_(i, node.items[i], visitor, path);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    node.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n        }\n        else if (isPair(node)) {\n            path = Object.freeze(path.concat(node));\n            const ck = await visitAsync_('key', node.key, visitor, path);\n            if (ck === BREAK)\n                return BREAK;\n            else if (ck === REMOVE)\n                node.key = null;\n            const cv = await visitAsync_('value', node.value, visitor, path);\n            if (cv === BREAK)\n                return BREAK;\n            else if (cv === REMOVE)\n                node.value = null;\n        }\n    }\n    return ctrl;\n}\nfunction initVisitor(visitor) {\n    if (typeof visitor === 'object' &&\n        (visitor.Collection || visitor.Node || visitor.Value)) {\n        return Object.assign({\n            Alias: visitor.Node,\n            Map: visitor.Node,\n            Scalar: visitor.Node,\n            Seq: visitor.Node\n        }, visitor.Value && {\n            Map: visitor.Value,\n            Scalar: visitor.Value,\n            Seq: visitor.Value\n        }, visitor.Collection && {\n            Map: visitor.Collection,\n            Seq: visitor.Collection\n        }, visitor);\n    }\n    return visitor;\n}\nfunction callVisitor(key, node, visitor, path) {\n    if (typeof visitor === 'function')\n        return visitor(key, node, path);\n    if (isMap(node))\n        return visitor.Map?.(key, node, path);\n    if (isSeq(node))\n        return visitor.Seq?.(key, node, path);\n    if (isPair(node))\n        return visitor.Pair?.(key, node, path);\n    if (isScalar(node))\n        return visitor.Scalar?.(key, node, path);\n    if (isAlias(node))\n        return visitor.Alias?.(key, node, path);\n    return undefined;\n}\nfunction replaceNode(key, path, node) {\n    const parent = path[path.length - 1];\n    if (isCollection(parent)) {\n        parent.items[key] = node;\n    }\n    else if (isPair(parent)) {\n        if (key === 'key')\n            parent.key = node;\n        else\n            parent.value = node;\n    }\n    else if (isDocument(parent)) {\n        parent.contents = node;\n    }\n    else {\n        const pt = isAlias(parent) ? 'alias' : 'scalar';\n        throw new Error(`Cannot replace node with ${pt} parent`);\n    }\n}\n\nexport { visit, visitAsync };\n","import { isNode } from '../nodes/Node.js';\nimport { visit } from '../visit.js';\n\nconst escapeChars = {\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n};\nconst escapeTagName = (tn) => tn.replace(/[!,[\\]{}]/g, ch => escapeChars[ch]);\nclass Directives {\n    constructor(yaml, tags) {\n        /**\n         * The directives-end/doc-start marker `---`. If `null`, a marker may still be\n         * included in the document's stringified representation.\n         */\n        this.docStart = null;\n        /** The doc-end marker `...`.  */\n        this.docEnd = false;\n        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);\n        this.tags = Object.assign({}, Directives.defaultTags, tags);\n    }\n    clone() {\n        const copy = new Directives(this.yaml, this.tags);\n        copy.docStart = this.docStart;\n        return copy;\n    }\n    /**\n     * During parsing, get a Directives instance for the current document and\n     * update the stream state according to the current version's spec.\n     */\n    atDocument() {\n        const res = new Directives(this.yaml, this.tags);\n        switch (this.yaml.version) {\n            case '1.1':\n                this.atNextDocument = true;\n                break;\n            case '1.2':\n                this.atNextDocument = false;\n                this.yaml = {\n                    explicit: Directives.defaultYaml.explicit,\n                    version: '1.2'\n                };\n                this.tags = Object.assign({}, Directives.defaultTags);\n                break;\n        }\n        return res;\n    }\n    /**\n     * @param onError - May be called even if the action was successful\n     * @returns `true` on success\n     */\n    add(line, onError) {\n        if (this.atNextDocument) {\n            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };\n            this.tags = Object.assign({}, Directives.defaultTags);\n            this.atNextDocument = false;\n        }\n        const parts = line.trim().split(/[ \\t]+/);\n        const name = parts.shift();\n        switch (name) {\n            case '%TAG': {\n                if (parts.length !== 2) {\n                    onError(0, '%TAG directive should contain exactly two parts');\n                    if (parts.length < 2)\n                        return false;\n                }\n                const [handle, prefix] = parts;\n                this.tags[handle] = prefix;\n                return true;\n            }\n            case '%YAML': {\n                this.yaml.explicit = true;\n                if (parts.length !== 1) {\n                    onError(0, '%YAML directive should contain exactly one part');\n                    return false;\n                }\n                const [version] = parts;\n                if (version === '1.1' || version === '1.2') {\n                    this.yaml.version = version;\n                    return true;\n                }\n                else {\n                    const isValid = /^\\d+\\.\\d+$/.test(version);\n                    onError(6, `Unsupported YAML version ${version}`, isValid);\n                    return false;\n                }\n            }\n            default:\n                onError(0, `Unknown directive ${name}`, true);\n                return false;\n        }\n    }\n    /**\n     * Resolves a tag, matching handles to those defined in %TAG directives.\n     *\n     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a\n     *   `'!local'` tag, or `null` if unresolvable.\n     */\n    tagName(source, onError) {\n        if (source === '!')\n            return '!'; // non-specific tag\n        if (source[0] !== '!') {\n            onError(`Not a valid tag: ${source}`);\n            return null;\n        }\n        if (source[1] === '<') {\n            const verbatim = source.slice(2, -1);\n            if (verbatim === '!' || verbatim === '!!') {\n                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);\n                return null;\n            }\n            if (source[source.length - 1] !== '>')\n                onError('Verbatim tags must end with a >');\n            return verbatim;\n        }\n        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);\n        if (!suffix)\n            onError(`The ${source} tag has no suffix`);\n        const prefix = this.tags[handle];\n        if (prefix)\n            return prefix + decodeURIComponent(suffix);\n        if (handle === '!')\n            return source; // local tag\n        onError(`Could not resolve tag: ${source}`);\n        return null;\n    }\n    /**\n     * Given a fully resolved tag, returns its printable string form,\n     * taking into account current tag prefixes and defaults.\n     */\n    tagString(tag) {\n        for (const [handle, prefix] of Object.entries(this.tags)) {\n            if (tag.startsWith(prefix))\n                return handle + escapeTagName(tag.substring(prefix.length));\n        }\n        return tag[0] === '!' ? tag : `!<${tag}>`;\n    }\n    toString(doc) {\n        const lines = this.yaml.explicit\n            ? [`%YAML ${this.yaml.version || '1.2'}`]\n            : [];\n        const tagEntries = Object.entries(this.tags);\n        let tagNames;\n        if (doc && tagEntries.length > 0 && isNode(doc.contents)) {\n            const tags = {};\n            visit(doc.contents, (_key, node) => {\n                if (isNode(node) && node.tag)\n                    tags[node.tag] = true;\n            });\n            tagNames = Object.keys(tags);\n        }\n        else\n            tagNames = [];\n        for (const [handle, prefix] of tagEntries) {\n            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')\n                continue;\n            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))\n                lines.push(`%TAG ${handle} ${prefix}`);\n        }\n        return lines.join('\\n');\n    }\n}\nDirectives.defaultYaml = { explicit: false, version: '1.2' };\nDirectives.defaultTags = { '!!': 'tag:yaml.org,2002:' };\n\nexport { Directives };\n","import { isScalar, isCollection } from '../nodes/Node.js';\nimport { visit } from '../visit.js';\n\n/**\n * Verify that the input string is a valid anchor.\n *\n * Will throw on errors.\n */\nfunction anchorIsValid(anchor) {\n    if (/[\\x00-\\x19\\s,[\\]{}]/.test(anchor)) {\n        const sa = JSON.stringify(anchor);\n        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;\n        throw new Error(msg);\n    }\n    return true;\n}\nfunction anchorNames(root) {\n    const anchors = new Set();\n    visit(root, {\n        Value(_key, node) {\n            if (node.anchor)\n                anchors.add(node.anchor);\n        }\n    });\n    return anchors;\n}\n/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */\nfunction findNewAnchor(prefix, exclude) {\n    for (let i = 1; true; ++i) {\n        const name = `${prefix}${i}`;\n        if (!exclude.has(name))\n            return name;\n    }\n}\nfunction createNodeAnchors(doc, prefix) {\n    const aliasObjects = [];\n    const sourceObjects = new Map();\n    let prevAnchors = null;\n    return {\n        onAnchor: (source) => {\n            aliasObjects.push(source);\n            if (!prevAnchors)\n                prevAnchors = anchorNames(doc);\n            const anchor = findNewAnchor(prefix, prevAnchors);\n            prevAnchors.add(anchor);\n            return anchor;\n        },\n        /**\n         * With circular references, the source node is only resolved after all\n         * of its child nodes are. This is why anchors are set only after all of\n         * the nodes have been created.\n         */\n        setAnchors: () => {\n            for (const source of aliasObjects) {\n                const ref = sourceObjects.get(source);\n                if (typeof ref === 'object' &&\n                    ref.anchor &&\n                    (isScalar(ref.node) || isCollection(ref.node))) {\n                    ref.node.anchor = ref.anchor;\n                }\n                else {\n                    const error = new Error('Failed to resolve repeated object (this should not happen)');\n                    error.source = source;\n                    throw error;\n                }\n            }\n        },\n        sourceObjects\n    };\n}\n\nexport { anchorIsValid, anchorNames, createNodeAnchors, findNewAnchor };\n","import { anchorIsValid } from '../doc/anchors.js';\nimport { visit } from '../visit.js';\nimport { NodeBase, ALIAS, isAlias, isCollection, isPair } from './Node.js';\n\nclass Alias extends NodeBase {\n    constructor(source) {\n        super(ALIAS);\n        this.source = source;\n        Object.defineProperty(this, 'tag', {\n            set() {\n                throw new Error('Alias nodes cannot have tags');\n            }\n        });\n    }\n    /**\n     * Resolve the value of this alias within `doc`, finding the last\n     * instance of the `source` anchor before this node.\n     */\n    resolve(doc) {\n        let found = undefined;\n        visit(doc, {\n            Node: (_key, node) => {\n                if (node === this)\n                    return visit.BREAK;\n                if (node.anchor === this.source)\n                    found = node;\n            }\n        });\n        return found;\n    }\n    toJSON(_arg, ctx) {\n        if (!ctx)\n            return { source: this.source };\n        const { anchors, doc, maxAliasCount } = ctx;\n        const source = this.resolve(doc);\n        if (!source) {\n            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n            throw new ReferenceError(msg);\n        }\n        const data = anchors.get(source);\n        /* istanbul ignore if */\n        if (!data || data.res === undefined) {\n            const msg = 'This should not happen: Alias anchor was not resolved?';\n            throw new ReferenceError(msg);\n        }\n        if (maxAliasCount >= 0) {\n            data.count += 1;\n            if (data.aliasCount === 0)\n                data.aliasCount = getAliasCount(doc, source, anchors);\n            if (data.count * data.aliasCount > maxAliasCount) {\n                const msg = 'Excessive alias count indicates a resource exhaustion attack';\n                throw new ReferenceError(msg);\n            }\n        }\n        return data.res;\n    }\n    toString(ctx, _onComment, _onChompKeep) {\n        const src = `*${this.source}`;\n        if (ctx) {\n            anchorIsValid(this.source);\n            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {\n                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n                throw new Error(msg);\n            }\n            if (ctx.implicitKey)\n                return `${src} `;\n        }\n        return src;\n    }\n}\nfunction getAliasCount(doc, node, anchors) {\n    if (isAlias(node)) {\n        const source = node.resolve(doc);\n        const anchor = anchors && source && anchors.get(source);\n        return anchor ? anchor.count * anchor.aliasCount : 0;\n    }\n    else if (isCollection(node)) {\n        let count = 0;\n        for (const item of node.items) {\n            const c = getAliasCount(doc, item, anchors);\n            if (c > count)\n                count = c;\n        }\n        return count;\n    }\n    else if (isPair(node)) {\n        const kc = getAliasCount(doc, node.key, anchors);\n        const vc = getAliasCount(doc, node.value, anchors);\n        return Math.max(kc, vc);\n    }\n    return 1;\n}\n\nexport { Alias };\n","import { hasAnchor } from './Node.js';\n\n/**\n * Recursively convert any node or its contents to native JavaScript\n *\n * @param value - The input value\n * @param arg - If `value` defines a `toJSON()` method, use this\n *   as its first argument\n * @param ctx - Conversion context, originally set in Document#toJS(). If\n *   `{ keep: true }` is not set, output should be suitable for JSON\n *   stringification.\n */\nfunction toJS(value, arg, ctx) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    if (Array.isArray(value))\n        return value.map((v, i) => toJS(v, String(i), ctx));\n    if (value && typeof value.toJSON === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        if (!ctx || !hasAnchor(value))\n            return value.toJSON(arg, ctx);\n        const data = { aliasCount: 0, count: 1, res: undefined };\n        ctx.anchors.set(value, data);\n        ctx.onCreate = res => {\n            data.res = res;\n            delete ctx.onCreate;\n        };\n        const res = value.toJSON(arg, ctx);\n        if (ctx.onCreate)\n            ctx.onCreate(res);\n        return res;\n    }\n    if (typeof value === 'bigint' && !ctx?.keep)\n        return Number(value);\n    return value;\n}\n\nexport { toJS };\n","import { NodeBase, SCALAR } from './Node.js';\nimport { toJS } from './toJS.js';\n\nconst isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');\nclass Scalar extends NodeBase {\n    constructor(value) {\n        super(SCALAR);\n        this.value = value;\n    }\n    toJSON(arg, ctx) {\n        return ctx?.keep ? this.value : toJS(this.value, arg, ctx);\n    }\n    toString() {\n        return String(this.value);\n    }\n}\nScalar.BLOCK_FOLDED = 'BLOCK_FOLDED';\nScalar.BLOCK_LITERAL = 'BLOCK_LITERAL';\nScalar.PLAIN = 'PLAIN';\nScalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';\nScalar.QUOTE_SINGLE = 'QUOTE_SINGLE';\n\nexport { Scalar, isScalarValue };\n","import { Alias } from '../nodes/Alias.js';\nimport { isNode, isPair, MAP, SEQ, isDocument } from '../nodes/Node.js';\nimport { Scalar } from '../nodes/Scalar.js';\n\nconst defaultTagPrefix = 'tag:yaml.org,2002:';\nfunction findTagObject(value, tagName, tags) {\n    if (tagName) {\n        const match = tags.filter(t => t.tag === tagName);\n        const tagObj = match.find(t => !t.format) ?? match[0];\n        if (!tagObj)\n            throw new Error(`Tag ${tagName} not found`);\n        return tagObj;\n    }\n    return tags.find(t => t.identify?.(value) && !t.format);\n}\nfunction createNode(value, tagName, ctx) {\n    if (isDocument(value))\n        value = value.contents;\n    if (isNode(value))\n        return value;\n    if (isPair(value)) {\n        const map = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);\n        map.items.push(value);\n        return map;\n    }\n    if (value instanceof String ||\n        value instanceof Number ||\n        value instanceof Boolean ||\n        (typeof BigInt === 'function' && value instanceof BigInt) // not supported everywhere\n    ) {\n        // https://tc39.es/ecma262/#sec-serializejsonproperty\n        value = value.valueOf();\n    }\n    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;\n    // Detect duplicate references to the same object & use Alias nodes for all\n    // after first. The `ref` wrapper allows for circular references to resolve.\n    let ref = undefined;\n    if (aliasDuplicateObjects && value && typeof value === 'object') {\n        ref = sourceObjects.get(value);\n        if (ref) {\n            if (!ref.anchor)\n                ref.anchor = onAnchor(value);\n            return new Alias(ref.anchor);\n        }\n        else {\n            ref = { anchor: null, node: null };\n            sourceObjects.set(value, ref);\n        }\n    }\n    if (tagName?.startsWith('!!'))\n        tagName = defaultTagPrefix + tagName.slice(2);\n    let tagObj = findTagObject(value, tagName, schema.tags);\n    if (!tagObj) {\n        if (value && typeof value.toJSON === 'function') {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            value = value.toJSON();\n        }\n        if (!value || typeof value !== 'object') {\n            const node = new Scalar(value);\n            if (ref)\n                ref.node = node;\n            return node;\n        }\n        tagObj =\n            value instanceof Map\n                ? schema[MAP]\n                : Symbol.iterator in Object(value)\n                    ? schema[SEQ]\n                    : schema[MAP];\n    }\n    if (onTagObj) {\n        onTagObj(tagObj);\n        delete ctx.onTagObj;\n    }\n    const node = tagObj?.createNode\n        ? tagObj.createNode(ctx.schema, value, ctx)\n        : new Scalar(value);\n    if (tagName)\n        node.tag = tagName;\n    if (ref)\n        ref.node = node;\n    return node;\n}\n\nexport { createNode };\n","import { createNode } from '../doc/createNode.js';\nimport { NodeBase, isNode, isPair, isCollection, isScalar } from './Node.js';\n\nfunction collectionFromPath(schema, path, value) {\n    let v = value;\n    for (let i = path.length - 1; i >= 0; --i) {\n        const k = path[i];\n        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {\n            const a = [];\n            a[k] = v;\n            v = a;\n        }\n        else {\n            v = new Map([[k, v]]);\n        }\n    }\n    return createNode(v, undefined, {\n        aliasDuplicateObjects: false,\n        keepUndefined: false,\n        onAnchor: () => {\n            throw new Error('This should not happen, please report a bug.');\n        },\n        schema,\n        sourceObjects: new Map()\n    });\n}\n// Type guard is intentionally a little wrong so as to be more useful,\n// as it does not cover untypable empty non-string iterables (e.g. []).\nconst isEmptyPath = (path) => path == null ||\n    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);\nclass Collection extends NodeBase {\n    constructor(type, schema) {\n        super(type);\n        Object.defineProperty(this, 'schema', {\n            value: schema,\n            configurable: true,\n            enumerable: false,\n            writable: true\n        });\n    }\n    /**\n     * Create a copy of this collection.\n     *\n     * @param schema - If defined, overwrites the original's schema\n     */\n    clone(schema) {\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n        if (schema)\n            copy.schema = schema;\n        copy.items = copy.items.map(it => isNode(it) || isPair(it) ? it.clone(schema) : it);\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /**\n     * Adds a value to the collection. For `!!map` and `!!omap` the value must\n     * be a Pair instance or a `{ key, value }` object, which may not have a key\n     * that already exists in the map.\n     */\n    addIn(path, value) {\n        if (isEmptyPath(path))\n            this.add(value);\n        else {\n            const [key, ...rest] = path;\n            const node = this.get(key, true);\n            if (isCollection(node))\n                node.addIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n    /**\n     * Removes a value from the collection.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.delete(key);\n        const node = this.get(key, true);\n        if (isCollection(node))\n            return node.deleteIn(rest);\n        else\n            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        const [key, ...rest] = path;\n        const node = this.get(key, true);\n        if (rest.length === 0)\n            return !keepScalar && isScalar(node) ? node.value : node;\n        else\n            return isCollection(node) ? node.getIn(rest, keepScalar) : undefined;\n    }\n    hasAllNullValues(allowScalar) {\n        return this.items.every(node => {\n            if (!isPair(node))\n                return false;\n            const n = node.value;\n            return (n == null ||\n                (allowScalar &&\n                    isScalar(n) &&\n                    n.value == null &&\n                    !n.commentBefore &&\n                    !n.comment &&\n                    !n.tag));\n        });\n    }\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     */\n    hasIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.has(key);\n        const node = this.get(key, true);\n        return isCollection(node) ? node.hasIn(rest) : false;\n    }\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        const [key, ...rest] = path;\n        if (rest.length === 0) {\n            this.set(key, value);\n        }\n        else {\n            const node = this.get(key, true);\n            if (isCollection(node))\n                node.setIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n}\nCollection.maxFlowStringSingleLineLength = 60;\n\nexport { Collection, collectionFromPath, isEmptyPath };\n","/**\n * Stringifies a comment.\n *\n * Empty comment lines are left empty,\n * lines consisting of a single space are replaced by `#`,\n * and all other lines are prefixed with a `#`.\n */\nconst stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, '#');\nfunction indentComment(comment, indent) {\n    if (/^\\n+$/.test(comment))\n        return comment.substring(1);\n    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;\n}\nconst lineComment = (str, indent, comment) => str.endsWith('\\n')\n    ? indentComment(comment, indent)\n    : comment.includes('\\n')\n        ? '\\n' + indentComment(comment, indent)\n        : (str.endsWith(' ') ? '' : ' ') + comment;\n\nexport { indentComment, lineComment, stringifyComment };\n","const FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted';\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n */\nfunction foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {\n    if (!lineWidth || lineWidth < 0)\n        return text;\n    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n    if (text.length <= endStep)\n        return text;\n    const folds = [];\n    const escapedFolds = {};\n    let end = lineWidth - indent.length;\n    if (typeof indentAtStart === 'number') {\n        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))\n            folds.push(0);\n        else\n            end = lineWidth - indentAtStart;\n    }\n    let split = undefined;\n    let prev = undefined;\n    let overflow = false;\n    let i = -1;\n    let escStart = -1;\n    let escEnd = -1;\n    if (mode === FOLD_BLOCK) {\n        i = consumeMoreIndentedLines(text, i);\n        if (i !== -1)\n            end = i + endStep;\n    }\n    for (let ch; (ch = text[(i += 1)]);) {\n        if (mode === FOLD_QUOTED && ch === '\\\\') {\n            escStart = i;\n            switch (text[i + 1]) {\n                case 'x':\n                    i += 3;\n                    break;\n                case 'u':\n                    i += 5;\n                    break;\n                case 'U':\n                    i += 9;\n                    break;\n                default:\n                    i += 1;\n            }\n            escEnd = i;\n        }\n        if (ch === '\\n') {\n            if (mode === FOLD_BLOCK)\n                i = consumeMoreIndentedLines(text, i);\n            end = i + endStep;\n            split = undefined;\n        }\n        else {\n            if (ch === ' ' &&\n                prev &&\n                prev !== ' ' &&\n                prev !== '\\n' &&\n                prev !== '\\t') {\n                // space surrounded by non-space can be replaced with newline + indent\n                const next = text[i + 1];\n                if (next && next !== ' ' && next !== '\\n' && next !== '\\t')\n                    split = i;\n            }\n            if (i >= end) {\n                if (split) {\n                    folds.push(split);\n                    end = split + endStep;\n                    split = undefined;\n                }\n                else if (mode === FOLD_QUOTED) {\n                    // white-space collected at end may stretch past lineWidth\n                    while (prev === ' ' || prev === '\\t') {\n                        prev = ch;\n                        ch = text[(i += 1)];\n                        overflow = true;\n                    }\n                    // Account for newline escape, but don't break preceding escape\n                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;\n                    // Bail out if lineWidth & minContentWidth are shorter than an escape string\n                    if (escapedFolds[j])\n                        return text;\n                    folds.push(j);\n                    escapedFolds[j] = true;\n                    end = j + endStep;\n                    split = undefined;\n                }\n                else {\n                    overflow = true;\n                }\n            }\n        }\n        prev = ch;\n    }\n    if (overflow && onOverflow)\n        onOverflow();\n    if (folds.length === 0)\n        return text;\n    if (onFold)\n        onFold();\n    let res = text.slice(0, folds[0]);\n    for (let i = 0; i < folds.length; ++i) {\n        const fold = folds[i];\n        const end = folds[i + 1] || text.length;\n        if (fold === 0)\n            res = `\\n${indent}${text.slice(0, end)}`;\n        else {\n            if (mode === FOLD_QUOTED && escapedFolds[fold])\n                res += `${text[fold]}\\\\`;\n            res += `\\n${indent}${text.slice(fold + 1, end)}`;\n        }\n    }\n    return res;\n}\n/**\n * Presumes `i + 1` is at the start of a line\n * @returns index of last newline in more-indented block\n */\nfunction consumeMoreIndentedLines(text, i) {\n    let ch = text[i + 1];\n    while (ch === ' ' || ch === '\\t') {\n        do {\n            ch = text[(i += 1)];\n        } while (ch && ch !== '\\n');\n        ch = text[i + 1];\n    }\n    return i;\n}\n\nexport { FOLD_BLOCK, FOLD_FLOW, FOLD_QUOTED, foldFlowLines };\n","import { Scalar } from '../nodes/Scalar.js';\nimport { foldFlowLines, FOLD_QUOTED, FOLD_FLOW, FOLD_BLOCK } from './foldFlowLines.js';\n\nconst getFoldOptions = (ctx) => ({\n    indentAtStart: ctx.indentAtStart,\n    lineWidth: ctx.options.lineWidth,\n    minContentWidth: ctx.options.minContentWidth\n});\n// Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\nconst containsDocumentMarker = (str) => /^(%|---|\\.\\.\\.)/m.test(str);\nfunction lineLengthOverLimit(str, lineWidth, indentLength) {\n    if (!lineWidth || lineWidth < 0)\n        return false;\n    const limit = lineWidth - indentLength;\n    const strLen = str.length;\n    if (strLen <= limit)\n        return false;\n    for (let i = 0, start = 0; i < strLen; ++i) {\n        if (str[i] === '\\n') {\n            if (i - start > limit)\n                return true;\n            start = i + 1;\n            if (strLen - start <= limit)\n                return false;\n        }\n    }\n    return true;\n}\nfunction doubleQuotedString(value, ctx) {\n    const json = JSON.stringify(value);\n    if (ctx.options.doubleQuotedAsJSON)\n        return json;\n    const { implicitKey } = ctx;\n    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n    let str = '';\n    let start = 0;\n    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\n        if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n            // space before newline needs to be escaped to not be folded\n            str += json.slice(start, i) + '\\\\ ';\n            i += 1;\n            start = i;\n            ch = '\\\\';\n        }\n        if (ch === '\\\\')\n            switch (json[i + 1]) {\n                case 'u':\n                    {\n                        str += json.slice(start, i);\n                        const code = json.substr(i + 2, 4);\n                        switch (code) {\n                            case '0000':\n                                str += '\\\\0';\n                                break;\n                            case '0007':\n                                str += '\\\\a';\n                                break;\n                            case '000b':\n                                str += '\\\\v';\n                                break;\n                            case '001b':\n                                str += '\\\\e';\n                                break;\n                            case '0085':\n                                str += '\\\\N';\n                                break;\n                            case '00a0':\n                                str += '\\\\_';\n                                break;\n                            case '2028':\n                                str += '\\\\L';\n                                break;\n                            case '2029':\n                                str += '\\\\P';\n                                break;\n                            default:\n                                if (code.substr(0, 2) === '00')\n                                    str += '\\\\x' + code.substr(2);\n                                else\n                                    str += json.substr(i, 6);\n                        }\n                        i += 5;\n                        start = i + 1;\n                    }\n                    break;\n                case 'n':\n                    if (implicitKey ||\n                        json[i + 2] === '\"' ||\n                        json.length < minMultiLineLength) {\n                        i += 1;\n                    }\n                    else {\n                        // folding will eat first newline\n                        str += json.slice(start, i) + '\\n\\n';\n                        while (json[i + 2] === '\\\\' &&\n                            json[i + 3] === 'n' &&\n                            json[i + 4] !== '\"') {\n                            str += '\\n';\n                            i += 2;\n                        }\n                        str += indent;\n                        // space after newline needs to be escaped to not be folded\n                        if (json[i + 2] === ' ')\n                            str += '\\\\';\n                        i += 1;\n                        start = i + 1;\n                    }\n                    break;\n                default:\n                    i += 1;\n            }\n    }\n    str = start ? str + json.slice(start) : json;\n    return implicitKey\n        ? str\n        : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));\n}\nfunction singleQuotedString(value, ctx) {\n    if (ctx.options.singleQuote === false ||\n        (ctx.implicitKey && value.includes('\\n')) ||\n        /[ \\t]\\n|\\n[ \\t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline\n    )\n        return doubleQuotedString(value, ctx);\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n    const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n    return ctx.implicitKey\n        ? res\n        : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));\n}\nfunction quotedString(value, ctx) {\n    const { singleQuote } = ctx.options;\n    let qs;\n    if (singleQuote === false)\n        qs = doubleQuotedString;\n    else {\n        const hasDouble = value.includes('\"');\n        const hasSingle = value.includes(\"'\");\n        if (hasDouble && !hasSingle)\n            qs = singleQuotedString;\n        else if (hasSingle && !hasDouble)\n            qs = doubleQuotedString;\n        else\n            qs = singleQuote ? singleQuotedString : doubleQuotedString;\n    }\n    return qs(value, ctx);\n}\nfunction blockString({ comment, type, value }, ctx, onComment, onChompKeep) {\n    const { blockQuote, commentString, lineWidth } = ctx.options;\n    // 1. Block can't end in whitespace unless the last line is non-empty.\n    // 2. Strings consisting of only whitespace are best rendered explicitly.\n    if (!blockQuote || /\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n        return quotedString(value, ctx);\n    }\n    const indent = ctx.indent ||\n        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n    const literal = blockQuote === 'literal'\n        ? true\n        : blockQuote === 'folded' || type === Scalar.BLOCK_FOLDED\n            ? false\n            : type === Scalar.BLOCK_LITERAL\n                ? true\n                : !lineLengthOverLimit(value, lineWidth, indent.length);\n    if (!value)\n        return literal ? '|\\n' : '>\\n';\n    // determine chomping from whitespace at value end\n    let chomp;\n    let endStart;\n    for (endStart = value.length; endStart > 0; --endStart) {\n        const ch = value[endStart - 1];\n        if (ch !== '\\n' && ch !== '\\t' && ch !== ' ')\n            break;\n    }\n    let end = value.substring(endStart);\n    const endNlPos = end.indexOf('\\n');\n    if (endNlPos === -1) {\n        chomp = '-'; // strip\n    }\n    else if (value === end || endNlPos !== end.length - 1) {\n        chomp = '+'; // keep\n        if (onChompKeep)\n            onChompKeep();\n    }\n    else {\n        chomp = ''; // clip\n    }\n    if (end) {\n        value = value.slice(0, -end.length);\n        if (end[end.length - 1] === '\\n')\n            end = end.slice(0, -1);\n        end = end.replace(/\\n+(?!\\n|$)/g, `$&${indent}`);\n    }\n    // determine indent indicator from whitespace at value start\n    let startWithSpace = false;\n    let startEnd;\n    let startNlPos = -1;\n    for (startEnd = 0; startEnd < value.length; ++startEnd) {\n        const ch = value[startEnd];\n        if (ch === ' ')\n            startWithSpace = true;\n        else if (ch === '\\n')\n            startNlPos = startEnd;\n        else\n            break;\n    }\n    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);\n    if (start) {\n        value = value.substring(start.length);\n        start = start.replace(/\\n+/g, `$&${indent}`);\n    }\n    const indentSize = indent ? '2' : '1'; // root is at -1\n    let header = (literal ? '|' : '>') + (startWithSpace ? indentSize : '') + chomp;\n    if (comment) {\n        header += ' ' + commentString(comment.replace(/ ?[\\r\\n]+/g, ' '));\n        if (onComment)\n            onComment();\n    }\n    if (literal) {\n        value = value.replace(/\\n+/g, `$&${indent}`);\n        return `${header}\\n${indent}${start}${value}${end}`;\n    }\n    value = value\n        .replace(/\\n+/g, '\\n$&')\n        .replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n        //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent\n        .replace(/\\n+/g, `$&${indent}`);\n    const body = foldFlowLines(`${start}${value}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx));\n    return `${header}\\n${indent}${body}`;\n}\nfunction plainString(item, ctx, onComment, onChompKeep) {\n    const { type, value } = item;\n    const { actualString, implicitKey, indent, inFlow } = ctx;\n    if ((implicitKey && /[\\n[\\]{},]/.test(value)) ||\n        (inFlow && /[[\\]{},]/.test(value))) {\n        return quotedString(value, ctx);\n    }\n    if (!value ||\n        /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n        // not allowed:\n        // - empty string, '-' or '?'\n        // - start with an indicator character (except [?:-]) or /[?-] /\n        // - '\\n ', ': ' or ' \\n' anywhere\n        // - '#' not preceded by a non-space char\n        // - end with ' ' or ':'\n        return implicitKey || inFlow || !value.includes('\\n')\n            ? quotedString(value, ctx)\n            : blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (!implicitKey &&\n        !inFlow &&\n        type !== Scalar.PLAIN &&\n        value.includes('\\n')) {\n        // Where allowed & type not set explicitly, prefer block style for multiline strings\n        return blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (indent === '' && containsDocumentMarker(value)) {\n        ctx.forceBlockIndent = true;\n        return blockString(item, ctx, onComment, onChompKeep);\n    }\n    const str = value.replace(/\\n+/g, `$&\\n${indent}`);\n    // Verify that output will be parsed as a string, as e.g. plain numbers and\n    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n    // and others in v1.1.\n    if (actualString) {\n        const test = (tag) => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);\n        const { compat, tags } = ctx.doc.schema;\n        if (tags.some(test) || compat?.some(test))\n            return quotedString(value, ctx);\n    }\n    return implicitKey\n        ? str\n        : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));\n}\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n    const { implicitKey, inFlow } = ctx;\n    const ss = typeof item.value === 'string'\n        ? item\n        : Object.assign({}, item, { value: String(item.value) });\n    let { type } = item;\n    if (type !== Scalar.QUOTE_DOUBLE) {\n        // force double quotes on control characters & unpaired surrogates\n        if (/[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f\\u{D800}-\\u{DFFF}]/u.test(ss.value))\n            type = Scalar.QUOTE_DOUBLE;\n    }\n    const _stringify = (_type) => {\n        switch (_type) {\n            case Scalar.BLOCK_FOLDED:\n            case Scalar.BLOCK_LITERAL:\n                return implicitKey || inFlow\n                    ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers\n                    : blockString(ss, ctx, onComment, onChompKeep);\n            case Scalar.QUOTE_DOUBLE:\n                return doubleQuotedString(ss.value, ctx);\n            case Scalar.QUOTE_SINGLE:\n                return singleQuotedString(ss.value, ctx);\n            case Scalar.PLAIN:\n                return plainString(ss, ctx, onComment, onChompKeep);\n            default:\n                return null;\n        }\n    };\n    let res = _stringify(type);\n    if (res === null) {\n        const { defaultKeyType, defaultStringType } = ctx.options;\n        const t = (implicitKey && defaultKeyType) || defaultStringType;\n        res = _stringify(t);\n        if (res === null)\n            throw new Error(`Unsupported default string type ${t}`);\n    }\n    return res;\n}\n\nexport { stringifyString };\n","import { anchorIsValid } from '../doc/anchors.js';\nimport { isPair, isAlias, isNode, isScalar, isCollection } from '../nodes/Node.js';\nimport { stringifyComment } from './stringifyComment.js';\nimport { stringifyString } from './stringifyString.js';\n\nfunction createStringifyContext(doc, options) {\n    const opt = Object.assign({\n        blockQuote: true,\n        commentString: stringifyComment,\n        defaultKeyType: null,\n        defaultStringType: 'PLAIN',\n        directives: null,\n        doubleQuotedAsJSON: false,\n        doubleQuotedMinMultiLineLength: 40,\n        falseStr: 'false',\n        indentSeq: true,\n        lineWidth: 80,\n        minContentWidth: 20,\n        nullStr: 'null',\n        simpleKeys: false,\n        singleQuote: null,\n        trueStr: 'true',\n        verifyAliasOrder: true\n    }, doc.schema.toStringOptions, options);\n    let inFlow;\n    switch (opt.collectionStyle) {\n        case 'block':\n            inFlow = false;\n            break;\n        case 'flow':\n            inFlow = true;\n            break;\n        default:\n            inFlow = null;\n    }\n    return {\n        anchors: new Set(),\n        doc,\n        indent: '',\n        indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',\n        inFlow,\n        options: opt\n    };\n}\nfunction getTagObject(tags, item) {\n    if (item.tag) {\n        const match = tags.filter(t => t.tag === item.tag);\n        if (match.length > 0)\n            return match.find(t => t.format === item.format) ?? match[0];\n    }\n    let tagObj = undefined;\n    let obj;\n    if (isScalar(item)) {\n        obj = item.value;\n        const match = tags.filter(t => t.identify?.(obj));\n        tagObj =\n            match.find(t => t.format === item.format) ?? match.find(t => !t.format);\n    }\n    else {\n        obj = item;\n        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);\n    }\n    if (!tagObj) {\n        const name = obj?.constructor?.name ?? typeof obj;\n        throw new Error(`Tag not resolved for ${name} value`);\n    }\n    return tagObj;\n}\n// needs to be called before value stringifier to allow for circular anchor refs\nfunction stringifyProps(node, tagObj, { anchors, doc }) {\n    if (!doc.directives)\n        return '';\n    const props = [];\n    const anchor = (isScalar(node) || isCollection(node)) && node.anchor;\n    if (anchor && anchorIsValid(anchor)) {\n        anchors.add(anchor);\n        props.push(`&${anchor}`);\n    }\n    const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;\n    if (tag)\n        props.push(doc.directives.tagString(tag));\n    return props.join(' ');\n}\nfunction stringify(item, ctx, onComment, onChompKeep) {\n    if (isPair(item))\n        return item.toString(ctx, onComment, onChompKeep);\n    if (isAlias(item)) {\n        if (ctx.doc.directives)\n            return item.toString(ctx);\n        if (ctx.resolvedAliases?.has(item)) {\n            throw new TypeError(`Cannot stringify circular structure without alias nodes`);\n        }\n        else {\n            if (ctx.resolvedAliases)\n                ctx.resolvedAliases.add(item);\n            else\n                ctx.resolvedAliases = new Set([item]);\n            item = item.resolve(ctx.doc);\n        }\n    }\n    let tagObj = undefined;\n    const node = isNode(item)\n        ? item\n        : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });\n    if (!tagObj)\n        tagObj = getTagObject(ctx.doc.schema.tags, node);\n    const props = stringifyProps(node, tagObj, ctx);\n    if (props.length > 0)\n        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;\n    const str = typeof tagObj.stringify === 'function'\n        ? tagObj.stringify(node, ctx, onComment, onChompKeep)\n        : isScalar(node)\n            ? stringifyString(node, ctx, onComment, onChompKeep)\n            : node.toString(ctx, onComment, onChompKeep);\n    if (!props)\n        return str;\n    return isScalar(node) || str[0] === '{' || str[0] === '['\n        ? `${props} ${str}`\n        : `${props}\\n${ctx.indent}${str}`;\n}\n\nexport { createStringifyContext, stringify };\n","function debug(logLevel, ...messages) {\n    if (logLevel === 'debug')\n        console.log(...messages);\n}\nfunction warn(logLevel, warning) {\n    if (logLevel === 'debug' || logLevel === 'warn') {\n        if (typeof process !== 'undefined' && process.emitWarning)\n            process.emitWarning(warning);\n        else\n            console.warn(warning);\n    }\n}\n\nexport { debug, warn };\n","import { warn } from '../log.js';\nimport { createStringifyContext } from '../stringify/stringify.js';\nimport { isAlias, isSeq, isScalar, isMap, isNode } from './Node.js';\nimport { Scalar } from './Scalar.js';\nimport { toJS } from './toJS.js';\n\nconst MERGE_KEY = '<<';\nfunction addPairToJSMap(ctx, map, { key, value }) {\n    if (ctx?.doc.schema.merge && isMergeKey(key)) {\n        value = isAlias(value) ? value.resolve(ctx.doc) : value;\n        if (isSeq(value))\n            for (const it of value.items)\n                mergeToJSMap(ctx, map, it);\n        else if (Array.isArray(value))\n            for (const it of value)\n                mergeToJSMap(ctx, map, it);\n        else\n            mergeToJSMap(ctx, map, value);\n    }\n    else {\n        const jsKey = toJS(key, '', ctx);\n        if (map instanceof Map) {\n            map.set(jsKey, toJS(value, jsKey, ctx));\n        }\n        else if (map instanceof Set) {\n            map.add(jsKey);\n        }\n        else {\n            const stringKey = stringifyKey(key, jsKey, ctx);\n            const jsValue = toJS(value, stringKey, ctx);\n            if (stringKey in map)\n                Object.defineProperty(map, stringKey, {\n                    value: jsValue,\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                });\n            else\n                map[stringKey] = jsValue;\n        }\n    }\n    return map;\n}\nconst isMergeKey = (key) => key === MERGE_KEY ||\n    (isScalar(key) &&\n        key.value === MERGE_KEY &&\n        (!key.type || key.type === Scalar.PLAIN));\n// If the value associated with a merge key is a single mapping node, each of\n// its key/value pairs is inserted into the current mapping, unless the key\n// already exists in it. If the value associated with the merge key is a\n// sequence, then this sequence is expected to contain mapping nodes and each\n// of these nodes is merged in turn according to its order in the sequence.\n// Keys in mapping nodes earlier in the sequence override keys specified in\n// later mapping nodes. -- http://yaml.org/type/merge.html\nfunction mergeToJSMap(ctx, map, value) {\n    const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;\n    if (!isMap(source))\n        throw new Error('Merge sources must be maps or map aliases');\n    const srcMap = source.toJSON(null, ctx, Map);\n    for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n            if (!map.has(key))\n                map.set(key, value);\n        }\n        else if (map instanceof Set) {\n            map.add(key);\n        }\n        else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n            Object.defineProperty(map, key, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }\n    return map;\n}\nfunction stringifyKey(key, jsKey, ctx) {\n    if (jsKey === null)\n        return '';\n    if (typeof jsKey !== 'object')\n        return String(jsKey);\n    if (isNode(key) && ctx && ctx.doc) {\n        const strCtx = createStringifyContext(ctx.doc, {});\n        strCtx.anchors = new Set();\n        for (const node of ctx.anchors.keys())\n            strCtx.anchors.add(node.anchor);\n        strCtx.inFlow = true;\n        strCtx.inStringifyKey = true;\n        const strKey = key.toString(strCtx);\n        if (!ctx.mapKeyWarned) {\n            let jsonStr = JSON.stringify(strKey);\n            if (jsonStr.length > 40)\n                jsonStr = jsonStr.substring(0, 36) + '...\"';\n            warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);\n            ctx.mapKeyWarned = true;\n        }\n        return strKey;\n    }\n    return JSON.stringify(jsKey);\n}\n\nexport { addPairToJSMap };\n","import { createNode } from '../doc/createNode.js';\nimport { stringifyPair } from '../stringify/stringifyPair.js';\nimport { addPairToJSMap } from './addPairToJSMap.js';\nimport { NODE_TYPE, PAIR, isNode } from './Node.js';\n\nfunction createPair(key, value, ctx) {\n    const k = createNode(key, undefined, ctx);\n    const v = createNode(value, undefined, ctx);\n    return new Pair(k, v);\n}\nclass Pair {\n    constructor(key, value = null) {\n        Object.defineProperty(this, NODE_TYPE, { value: PAIR });\n        this.key = key;\n        this.value = value;\n    }\n    clone(schema) {\n        let { key, value } = this;\n        if (isNode(key))\n            key = key.clone(schema);\n        if (isNode(value))\n            value = value.clone(schema);\n        return new Pair(key, value);\n    }\n    toJSON(_, ctx) {\n        const pair = ctx?.mapAsMap ? new Map() : {};\n        return addPairToJSMap(ctx, pair, this);\n    }\n    toString(ctx, onComment, onChompKeep) {\n        return ctx?.doc\n            ? stringifyPair(this, ctx, onComment, onChompKeep)\n            : JSON.stringify(this);\n    }\n}\n\nexport { Pair, createPair };\n","import { isCollection, isNode, isScalar, isSeq } from '../nodes/Node.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { stringify } from './stringify.js';\nimport { lineComment, indentComment } from './stringifyComment.js';\n\nfunction stringifyPair({ key, value }, ctx, onComment, onChompKeep) {\n    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;\n    let keyComment = (isNode(key) && key.comment) || null;\n    if (simpleKeys) {\n        if (keyComment) {\n            throw new Error('With simple keys, key nodes cannot have comments');\n        }\n        if (isCollection(key)) {\n            const msg = 'With simple keys, collection cannot be used as a key value';\n            throw new Error(msg);\n        }\n    }\n    let explicitKey = !simpleKeys &&\n        (!key ||\n            (keyComment && value == null && !ctx.inFlow) ||\n            isCollection(key) ||\n            (isScalar(key)\n                ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL\n                : typeof key === 'object'));\n    ctx = Object.assign({}, ctx, {\n        allNullValues: false,\n        implicitKey: !explicitKey && (simpleKeys || !allNullValues),\n        indent: indent + indentStep\n    });\n    let keyCommentDone = false;\n    let chompKeep = false;\n    let str = stringify(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));\n    if (!explicitKey && !ctx.inFlow && str.length > 1024) {\n        if (simpleKeys)\n            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\n        explicitKey = true;\n    }\n    if (ctx.inFlow) {\n        if (allNullValues || value == null) {\n            if (keyCommentDone && onComment)\n                onComment();\n            return str === '' ? '?' : explicitKey ? `? ${str}` : str;\n        }\n    }\n    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {\n        str = `? ${str}`;\n        if (keyComment && !keyCommentDone) {\n            str += lineComment(str, ctx.indent, commentString(keyComment));\n        }\n        else if (chompKeep && onChompKeep)\n            onChompKeep();\n        return str;\n    }\n    if (keyCommentDone)\n        keyComment = null;\n    if (explicitKey) {\n        if (keyComment)\n            str += lineComment(str, ctx.indent, commentString(keyComment));\n        str = `? ${str}\\n${indent}:`;\n    }\n    else {\n        str = `${str}:`;\n        if (keyComment)\n            str += lineComment(str, ctx.indent, commentString(keyComment));\n    }\n    let vcb = '';\n    let valueComment = null;\n    if (isNode(value)) {\n        if (value.spaceBefore)\n            vcb = '\\n';\n        if (value.commentBefore) {\n            const cs = commentString(value.commentBefore);\n            vcb += `\\n${indentComment(cs, ctx.indent)}`;\n        }\n        valueComment = value.comment;\n    }\n    else if (value && typeof value === 'object') {\n        value = doc.createNode(value);\n    }\n    ctx.implicitKey = false;\n    if (!explicitKey && !keyComment && isScalar(value))\n        ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n    if (!indentSeq &&\n        indentStep.length >= 2 &&\n        !ctx.inFlow &&\n        !explicitKey &&\n        isSeq(value) &&\n        !value.flow &&\n        !value.tag &&\n        !value.anchor) {\n        // If indentSeq === false, consider '- ' as part of indentation where possible\n        ctx.indent = ctx.indent.substr(2);\n    }\n    let valueCommentDone = false;\n    const valueStr = stringify(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));\n    let ws = ' ';\n    if (vcb || keyComment) {\n        if (valueStr === '' && !ctx.inFlow)\n            ws = vcb === '\\n' ? '\\n\\n' : vcb;\n        else\n            ws = `${vcb}\\n${ctx.indent}`;\n    }\n    else if (!explicitKey && isCollection(value)) {\n        const flow = valueStr[0] === '[' || valueStr[0] === '{';\n        if (!flow || valueStr.includes('\\n'))\n            ws = `\\n${ctx.indent}`;\n    }\n    else if (valueStr === '' || valueStr[0] === '\\n')\n        ws = '';\n    str += ws + valueStr;\n    if (ctx.inFlow) {\n        if (valueCommentDone && onComment)\n            onComment();\n    }\n    else if (valueComment && !valueCommentDone) {\n        str += lineComment(str, ctx.indent, commentString(valueComment));\n    }\n    else if (chompKeep && onChompKeep) {\n        onChompKeep();\n    }\n    return str;\n}\n\nexport { stringifyPair };\n","import { Collection } from '../nodes/Collection.js';\nimport { isNode, isPair } from '../nodes/Node.js';\nimport { stringify } from './stringify.js';\nimport { lineComment, indentComment } from './stringifyComment.js';\n\nfunction stringifyCollection(collection, ctx, options) {\n    const flow = ctx.inFlow ?? collection.flow;\n    const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;\n    return stringify(collection, ctx, options);\n}\nfunction stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {\n    const { indent, options: { commentString } } = ctx;\n    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });\n    let chompKeep = false; // flag for the preceding node's status\n    const lines = [];\n    for (let i = 0; i < items.length; ++i) {\n        const item = items[i];\n        let comment = null;\n        if (isNode(item)) {\n            if (!chompKeep && item.spaceBefore)\n                lines.push('');\n            addCommentBefore(ctx, lines, item.commentBefore, chompKeep);\n            if (item.comment)\n                comment = item.comment;\n        }\n        else if (isPair(item)) {\n            const ik = isNode(item.key) ? item.key : null;\n            if (ik) {\n                if (!chompKeep && ik.spaceBefore)\n                    lines.push('');\n                addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);\n            }\n        }\n        chompKeep = false;\n        let str = stringify(item, itemCtx, () => (comment = null), () => (chompKeep = true));\n        if (comment)\n            str += lineComment(str, itemIndent, commentString(comment));\n        if (chompKeep && comment)\n            chompKeep = false;\n        lines.push(blockItemPrefix + str);\n    }\n    let str;\n    if (lines.length === 0) {\n        str = flowChars.start + flowChars.end;\n    }\n    else {\n        str = lines[0];\n        for (let i = 1; i < lines.length; ++i) {\n            const line = lines[i];\n            str += line ? `\\n${indent}${line}` : '\\n';\n        }\n    }\n    if (comment) {\n        str += '\\n' + indentComment(commentString(comment), indent);\n        if (onComment)\n            onComment();\n    }\n    else if (chompKeep && onChompKeep)\n        onChompKeep();\n    return str;\n}\nfunction stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {\n    const { indent, indentStep, options: { commentString } } = ctx;\n    itemIndent += indentStep;\n    const itemCtx = Object.assign({}, ctx, {\n        indent: itemIndent,\n        inFlow: true,\n        type: null\n    });\n    let reqNewline = false;\n    let linesAtValue = 0;\n    const lines = [];\n    for (let i = 0; i < items.length; ++i) {\n        const item = items[i];\n        let comment = null;\n        if (isNode(item)) {\n            if (item.spaceBefore)\n                lines.push('');\n            addCommentBefore(ctx, lines, item.commentBefore, false);\n            if (item.comment)\n                comment = item.comment;\n        }\n        else if (isPair(item)) {\n            const ik = isNode(item.key) ? item.key : null;\n            if (ik) {\n                if (ik.spaceBefore)\n                    lines.push('');\n                addCommentBefore(ctx, lines, ik.commentBefore, false);\n                if (ik.comment)\n                    reqNewline = true;\n            }\n            const iv = isNode(item.value) ? item.value : null;\n            if (iv) {\n                if (iv.comment)\n                    comment = iv.comment;\n                if (iv.commentBefore)\n                    reqNewline = true;\n            }\n            else if (item.value == null && ik && ik.comment) {\n                comment = ik.comment;\n            }\n        }\n        if (comment)\n            reqNewline = true;\n        let str = stringify(item, itemCtx, () => (comment = null));\n        if (i < items.length - 1)\n            str += ',';\n        if (comment)\n            str += lineComment(str, itemIndent, commentString(comment));\n        if (!reqNewline && (lines.length > linesAtValue || str.includes('\\n')))\n            reqNewline = true;\n        lines.push(str);\n        linesAtValue = lines.length;\n    }\n    let str;\n    const { start, end } = flowChars;\n    if (lines.length === 0) {\n        str = start + end;\n    }\n    else {\n        if (!reqNewline) {\n            const len = lines.reduce((sum, line) => sum + line.length + 2, 2);\n            reqNewline = len > Collection.maxFlowStringSingleLineLength;\n        }\n        if (reqNewline) {\n            str = start;\n            for (const line of lines)\n                str += line ? `\\n${indentStep}${indent}${line}` : '\\n';\n            str += `\\n${indent}${end}`;\n        }\n        else {\n            str = `${start} ${lines.join(' ')} ${end}`;\n        }\n    }\n    if (comment) {\n        str += lineComment(str, commentString(comment), indent);\n        if (onComment)\n            onComment();\n    }\n    return str;\n}\nfunction addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {\n    if (comment && chompKeep)\n        comment = comment.replace(/^\\n+/, '');\n    if (comment) {\n        const ic = indentComment(commentString(comment), indent);\n        lines.push(ic.trimStart()); // Avoid double indent on first line\n    }\n}\n\nexport { stringifyCollection };\n","import { stringifyCollection } from '../stringify/stringifyCollection.js';\nimport { addPairToJSMap } from './addPairToJSMap.js';\nimport { Collection } from './Collection.js';\nimport { isPair, isScalar, MAP } from './Node.js';\nimport { Pair } from './Pair.js';\nimport { isScalarValue } from './Scalar.js';\n\nfunction findPair(items, key) {\n    const k = isScalar(key) ? key.value : key;\n    for (const it of items) {\n        if (isPair(it)) {\n            if (it.key === key || it.key === k)\n                return it;\n            if (isScalar(it.key) && it.key.value === k)\n                return it;\n        }\n    }\n    return undefined;\n}\nclass YAMLMap extends Collection {\n    constructor(schema) {\n        super(MAP, schema);\n        this.items = [];\n    }\n    static get tagName() {\n        return 'tag:yaml.org,2002:map';\n    }\n    /**\n     * Adds a value to the collection.\n     *\n     * @param overwrite - If not set `true`, using a key that is already in the\n     *   collection will throw. Otherwise, overwrites the previous value.\n     */\n    add(pair, overwrite) {\n        let _pair;\n        if (isPair(pair))\n            _pair = pair;\n        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {\n            // In TypeScript, this never happens.\n            _pair = new Pair(pair, pair?.value);\n        }\n        else\n            _pair = new Pair(pair.key, pair.value);\n        const prev = findPair(this.items, _pair.key);\n        const sortEntries = this.schema?.sortMapEntries;\n        if (prev) {\n            if (!overwrite)\n                throw new Error(`Key ${_pair.key} already set`);\n            // For scalars, keep the old node & its comments and anchors\n            if (isScalar(prev.value) && isScalarValue(_pair.value))\n                prev.value.value = _pair.value;\n            else\n                prev.value = _pair.value;\n        }\n        else if (sortEntries) {\n            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);\n            if (i === -1)\n                this.items.push(_pair);\n            else\n                this.items.splice(i, 0, _pair);\n        }\n        else {\n            this.items.push(_pair);\n        }\n    }\n    delete(key) {\n        const it = findPair(this.items, key);\n        if (!it)\n            return false;\n        const del = this.items.splice(this.items.indexOf(it), 1);\n        return del.length > 0;\n    }\n    get(key, keepScalar) {\n        const it = findPair(this.items, key);\n        const node = it?.value;\n        return (!keepScalar && isScalar(node) ? node.value : node) ?? undefined;\n    }\n    has(key) {\n        return !!findPair(this.items, key);\n    }\n    set(key, value) {\n        this.add(new Pair(key, value), true);\n    }\n    /**\n     * @param ctx - Conversion context, originally set in Document#toJS()\n     * @param {Class} Type - If set, forces the returned collection type\n     * @returns Instance of Type, Map, or Object\n     */\n    toJSON(_, ctx, Type) {\n        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};\n        if (ctx?.onCreate)\n            ctx.onCreate(map);\n        for (const item of this.items)\n            addPairToJSMap(ctx, map, item);\n        return map;\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        for (const item of this.items) {\n            if (!isPair(item))\n                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n        }\n        if (!ctx.allNullValues && this.hasAllNullValues(false))\n            ctx = Object.assign({}, ctx, { allNullValues: true });\n        return stringifyCollection(this, ctx, {\n            blockItemPrefix: '',\n            flowChars: { start: '{', end: '}' },\n            itemIndent: ctx.indent || '',\n            onChompKeep,\n            onComment\n        });\n    }\n}\n\nexport { YAMLMap, findPair };\n","import { isMap } from '../../nodes/Node.js';\nimport { createPair } from '../../nodes/Pair.js';\nimport { YAMLMap } from '../../nodes/YAMLMap.js';\n\nfunction createMap(schema, obj, ctx) {\n    const { keepUndefined, replacer } = ctx;\n    const map = new YAMLMap(schema);\n    const add = (key, value) => {\n        if (typeof replacer === 'function')\n            value = replacer.call(obj, key, value);\n        else if (Array.isArray(replacer) && !replacer.includes(key))\n            return;\n        if (value !== undefined || keepUndefined)\n            map.items.push(createPair(key, value, ctx));\n    };\n    if (obj instanceof Map) {\n        for (const [key, value] of obj)\n            add(key, value);\n    }\n    else if (obj && typeof obj === 'object') {\n        for (const key of Object.keys(obj))\n            add(key, obj[key]);\n    }\n    if (typeof schema.sortMapEntries === 'function') {\n        map.items.sort(schema.sortMapEntries);\n    }\n    return map;\n}\nconst map = {\n    collection: 'map',\n    createNode: createMap,\n    default: true,\n    nodeClass: YAMLMap,\n    tag: 'tag:yaml.org,2002:map',\n    resolve(map, onError) {\n        if (!isMap(map))\n            onError('Expected a mapping for this tag');\n        return map;\n    }\n};\n\nexport { map };\n","import { stringifyCollection } from '../stringify/stringifyCollection.js';\nimport { Collection } from './Collection.js';\nimport { SEQ, isScalar } from './Node.js';\nimport { isScalarValue } from './Scalar.js';\nimport { toJS } from './toJS.js';\n\nclass YAMLSeq extends Collection {\n    constructor(schema) {\n        super(SEQ, schema);\n        this.items = [];\n    }\n    static get tagName() {\n        return 'tag:yaml.org,2002:seq';\n    }\n    add(value) {\n        this.items.push(value);\n    }\n    /**\n     * Removes a value from the collection.\n     *\n     * `key` must contain a representation of an integer for this to succeed.\n     * It may be wrapped in a `Scalar`.\n     *\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            return false;\n        const del = this.items.splice(idx, 1);\n        return del.length > 0;\n    }\n    get(key, keepScalar) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            return undefined;\n        const it = this.items[idx];\n        return !keepScalar && isScalar(it) ? it.value : it;\n    }\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     *\n     * `key` must contain a representation of an integer for this to succeed.\n     * It may be wrapped in a `Scalar`.\n     */\n    has(key) {\n        const idx = asItemIndex(key);\n        return typeof idx === 'number' && idx < this.items.length;\n    }\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     *\n     * If `key` does not contain a representation of an integer, this will throw.\n     * It may be wrapped in a `Scalar`.\n     */\n    set(key, value) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            throw new Error(`Expected a valid index, not ${key}.`);\n        const prev = this.items[idx];\n        if (isScalar(prev) && isScalarValue(value))\n            prev.value = value;\n        else\n            this.items[idx] = value;\n    }\n    toJSON(_, ctx) {\n        const seq = [];\n        if (ctx?.onCreate)\n            ctx.onCreate(seq);\n        let i = 0;\n        for (const item of this.items)\n            seq.push(toJS(item, String(i++), ctx));\n        return seq;\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        return stringifyCollection(this, ctx, {\n            blockItemPrefix: '- ',\n            flowChars: { start: '[', end: ']' },\n            itemIndent: (ctx.indent || '') + '  ',\n            onChompKeep,\n            onComment\n        });\n    }\n}\nfunction asItemIndex(key) {\n    let idx = isScalar(key) ? key.value : key;\n    if (idx && typeof idx === 'string')\n        idx = Number(idx);\n    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0\n        ? idx\n        : null;\n}\n\nexport { YAMLSeq };\n","import { createNode } from '../../doc/createNode.js';\nimport { isSeq } from '../../nodes/Node.js';\nimport { YAMLSeq } from '../../nodes/YAMLSeq.js';\n\nfunction createSeq(schema, obj, ctx) {\n    const { replacer } = ctx;\n    const seq = new YAMLSeq(schema);\n    if (obj && Symbol.iterator in Object(obj)) {\n        let i = 0;\n        for (let it of obj) {\n            if (typeof replacer === 'function') {\n                const key = obj instanceof Set ? it : String(i++);\n                it = replacer.call(obj, key, it);\n            }\n            seq.items.push(createNode(it, undefined, ctx));\n        }\n    }\n    return seq;\n}\nconst seq = {\n    collection: 'seq',\n    createNode: createSeq,\n    default: true,\n    nodeClass: YAMLSeq,\n    tag: 'tag:yaml.org,2002:seq',\n    resolve(seq, onError) {\n        if (!isSeq(seq))\n            onError('Expected a sequence for this tag');\n        return seq;\n    }\n};\n\nexport { seq };\n","import { stringifyString } from '../../stringify/stringifyString.js';\n\nconst string = {\n    identify: value => typeof value === 'string',\n    default: true,\n    tag: 'tag:yaml.org,2002:str',\n    resolve: str => str,\n    stringify(item, ctx, onComment, onChompKeep) {\n        ctx = Object.assign({ actualString: true }, ctx);\n        return stringifyString(item, ctx, onComment, onChompKeep);\n    }\n};\n\nexport { string };\n","import { Scalar } from '../../nodes/Scalar.js';\n\nconst nullTag = {\n    identify: value => value == null,\n    createNode: () => new Scalar(null),\n    default: true,\n    tag: 'tag:yaml.org,2002:null',\n    test: /^(?:~|[Nn]ull|NULL)?$/,\n    resolve: () => new Scalar(null),\n    stringify: ({ source }, ctx) => typeof source === 'string' && nullTag.test.test(source)\n        ? source\n        : ctx.options.nullStr\n};\n\nexport { nullTag };\n","import { Scalar } from '../../nodes/Scalar.js';\n\nconst boolTag = {\n    identify: value => typeof value === 'boolean',\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n    resolve: str => new Scalar(str[0] === 't' || str[0] === 'T'),\n    stringify({ source, value }, ctx) {\n        if (source && boolTag.test.test(source)) {\n            const sv = source[0] === 't' || source[0] === 'T';\n            if (value === sv)\n                return source;\n        }\n        return value ? ctx.options.trueStr : ctx.options.falseStr;\n    }\n};\n\nexport { boolTag };\n","function stringifyNumber({ format, minFractionDigits, tag, value }) {\n    if (typeof value === 'bigint')\n        return String(value);\n    const num = typeof value === 'number' ? value : Number(value);\n    if (!isFinite(num))\n        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';\n    let n = JSON.stringify(value);\n    if (!format &&\n        minFractionDigits &&\n        (!tag || tag === 'tag:yaml.org,2002:float') &&\n        /^\\d/.test(n)) {\n        let i = n.indexOf('.');\n        if (i < 0) {\n            i = n.length;\n            n += '.';\n        }\n        let d = minFractionDigits - (n.length - i - 1);\n        while (d-- > 0)\n            n += '0';\n    }\n    return n;\n}\n\nexport { stringifyNumber };\n","import { Scalar } from '../../nodes/Scalar.js';\nimport { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\nconst floatNaN = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^(?:[-+]?\\.(?:inf|Inf|INF|nan|NaN|NAN))$/,\n    resolve: str => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber\n};\nconst floatExp = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n    resolve: str => parseFloat(str),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber(node);\n    }\n};\nconst float = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+\\.[0-9]*)$/,\n    resolve(str) {\n        const node = new Scalar(parseFloat(str));\n        const dot = str.indexOf('.');\n        if (dot !== -1 && str[str.length - 1] === '0')\n            node.minFractionDigits = str.length - dot - 1;\n        return node;\n    },\n    stringify: stringifyNumber\n};\n\nexport { float, floatExp, floatNaN };\n","import { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\nconst intResolve = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value) && value >= 0)\n        return prefix + value.toString(radix);\n    return stringifyNumber(node);\n}\nconst intOct = {\n    identify: value => intIdentify(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^0o[0-7]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),\n    stringify: node => intStringify(node, 8, '0o')\n};\nconst int = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\n    stringify: stringifyNumber\n};\nconst intHex = {\n    identify: value => intIdentify(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^0x[0-9a-fA-F]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\n    stringify: node => intStringify(node, 16, '0x')\n};\n\nexport { int, intHex, intOct };\n","import { map } from '../common/map.js';\nimport { nullTag } from '../common/null.js';\nimport { seq } from '../common/seq.js';\nimport { string } from '../common/string.js';\nimport { boolTag } from './bool.js';\nimport { floatNaN, floatExp, float } from './float.js';\nimport { intOct, int, intHex } from './int.js';\n\nconst schema = [\n    map,\n    seq,\n    string,\n    nullTag,\n    boolTag,\n    intOct,\n    int,\n    intHex,\n    floatNaN,\n    floatExp,\n    float\n];\n\nexport { schema };\n","import { Scalar } from '../../nodes/Scalar.js';\nimport { map } from '../common/map.js';\nimport { seq } from '../common/seq.js';\n\nfunction intIdentify(value) {\n    return typeof value === 'bigint' || Number.isInteger(value);\n}\nconst stringifyJSON = ({ value }) => JSON.stringify(value);\nconst jsonScalars = [\n    {\n        identify: value => typeof value === 'string',\n        default: true,\n        tag: 'tag:yaml.org,2002:str',\n        resolve: str => str,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => value == null,\n        createNode: () => new Scalar(null),\n        default: true,\n        tag: 'tag:yaml.org,2002:null',\n        test: /^null$/,\n        resolve: () => null,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => typeof value === 'boolean',\n        default: true,\n        tag: 'tag:yaml.org,2002:bool',\n        test: /^true|false$/,\n        resolve: str => str === 'true',\n        stringify: stringifyJSON\n    },\n    {\n        identify: intIdentify,\n        default: true,\n        tag: 'tag:yaml.org,2002:int',\n        test: /^-?(?:0|[1-9][0-9]*)$/,\n        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),\n        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)\n    },\n    {\n        identify: value => typeof value === 'number',\n        default: true,\n        tag: 'tag:yaml.org,2002:float',\n        test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n        resolve: str => parseFloat(str),\n        stringify: stringifyJSON\n    }\n];\nconst jsonError = {\n    default: true,\n    tag: '',\n    test: /^/,\n    resolve(str, onError) {\n        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);\n        return str;\n    }\n};\nconst schema = [map, seq].concat(jsonScalars, jsonError);\n\nexport { schema };\n","import { Scalar } from '../../nodes/Scalar.js';\nimport { stringifyString } from '../../stringify/stringifyString.js';\n\nconst binary = {\n    identify: value => value instanceof Uint8Array,\n    default: false,\n    tag: 'tag:yaml.org,2002:binary',\n    /**\n     * Returns a Buffer in node and an Uint8Array in browsers\n     *\n     * To use the resulting buffer as an image, you'll want to do something like:\n     *\n     *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n     *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n     */\n    resolve(src, onError) {\n        if (typeof Buffer === 'function') {\n            return Buffer.from(src, 'base64');\n        }\n        else if (typeof atob === 'function') {\n            // On IE 11, atob() can't handle newlines\n            const str = atob(src.replace(/[\\n\\r]/g, ''));\n            const buffer = new Uint8Array(str.length);\n            for (let i = 0; i < str.length; ++i)\n                buffer[i] = str.charCodeAt(i);\n            return buffer;\n        }\n        else {\n            onError('This environment does not support reading binary tags; either Buffer or atob is required');\n            return src;\n        }\n    },\n    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {\n        const buf = value; // checked earlier by binary.identify()\n        let str;\n        if (typeof Buffer === 'function') {\n            str =\n                buf instanceof Buffer\n                    ? buf.toString('base64')\n                    : Buffer.from(buf.buffer).toString('base64');\n        }\n        else if (typeof btoa === 'function') {\n            let s = '';\n            for (let i = 0; i < buf.length; ++i)\n                s += String.fromCharCode(buf[i]);\n            str = btoa(s);\n        }\n        else {\n            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n        }\n        if (!type)\n            type = Scalar.BLOCK_LITERAL;\n        if (type !== Scalar.QUOTE_DOUBLE) {\n            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);\n            const n = Math.ceil(str.length / lineWidth);\n            const lines = new Array(n);\n            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n                lines[i] = str.substr(o, lineWidth);\n            }\n            str = lines.join(type === Scalar.BLOCK_LITERAL ? '\\n' : ' ');\n        }\n        return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);\n    }\n};\n\nexport { binary };\n","import { isSeq, isPair, isMap } from '../../nodes/Node.js';\nimport { Pair, createPair } from '../../nodes/Pair.js';\nimport { Scalar } from '../../nodes/Scalar.js';\nimport { YAMLSeq } from '../../nodes/YAMLSeq.js';\n\nfunction resolvePairs(seq, onError) {\n    if (isSeq(seq)) {\n        for (let i = 0; i < seq.items.length; ++i) {\n            let item = seq.items[i];\n            if (isPair(item))\n                continue;\n            else if (isMap(item)) {\n                if (item.items.length > 1)\n                    onError('Each pair must have its own sequence indicator');\n                const pair = item.items[0] || new Pair(new Scalar(null));\n                if (item.commentBefore)\n                    pair.key.commentBefore = pair.key.commentBefore\n                        ? `${item.commentBefore}\\n${pair.key.commentBefore}`\n                        : item.commentBefore;\n                if (item.comment) {\n                    const cn = pair.value ?? pair.key;\n                    cn.comment = cn.comment\n                        ? `${item.comment}\\n${cn.comment}`\n                        : item.comment;\n                }\n                item = pair;\n            }\n            seq.items[i] = isPair(item) ? item : new Pair(item);\n        }\n    }\n    else\n        onError('Expected a sequence for this tag');\n    return seq;\n}\nfunction createPairs(schema, iterable, ctx) {\n    const { replacer } = ctx;\n    const pairs = new YAMLSeq(schema);\n    pairs.tag = 'tag:yaml.org,2002:pairs';\n    let i = 0;\n    if (iterable && Symbol.iterator in Object(iterable))\n        for (let it of iterable) {\n            if (typeof replacer === 'function')\n                it = replacer.call(iterable, String(i++), it);\n            let key, value;\n            if (Array.isArray(it)) {\n                if (it.length === 2) {\n                    key = it[0];\n                    value = it[1];\n                }\n                else\n                    throw new TypeError(`Expected [key, value] tuple: ${it}`);\n            }\n            else if (it && it instanceof Object) {\n                const keys = Object.keys(it);\n                if (keys.length === 1) {\n                    key = keys[0];\n                    value = it[key];\n                }\n                else\n                    throw new TypeError(`Expected { key: value } tuple: ${it}`);\n            }\n            else {\n                key = it;\n            }\n            pairs.items.push(createPair(key, value, ctx));\n        }\n    return pairs;\n}\nconst pairs = {\n    collection: 'seq',\n    default: false,\n    tag: 'tag:yaml.org,2002:pairs',\n    resolve: resolvePairs,\n    createNode: createPairs\n};\n\nexport { createPairs, pairs, resolvePairs };\n","import { YAMLSeq } from '../../nodes/YAMLSeq.js';\nimport { toJS } from '../../nodes/toJS.js';\nimport { isScalar, isPair } from '../../nodes/Node.js';\nimport { YAMLMap } from '../../nodes/YAMLMap.js';\nimport { resolvePairs, createPairs } from './pairs.js';\n\nclass YAMLOMap extends YAMLSeq {\n    constructor() {\n        super();\n        this.add = YAMLMap.prototype.add.bind(this);\n        this.delete = YAMLMap.prototype.delete.bind(this);\n        this.get = YAMLMap.prototype.get.bind(this);\n        this.has = YAMLMap.prototype.has.bind(this);\n        this.set = YAMLMap.prototype.set.bind(this);\n        this.tag = YAMLOMap.tag;\n    }\n    /**\n     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,\n     * but TypeScript won't allow widening the signature of a child method.\n     */\n    toJSON(_, ctx) {\n        if (!ctx)\n            return super.toJSON(_);\n        const map = new Map();\n        if (ctx?.onCreate)\n            ctx.onCreate(map);\n        for (const pair of this.items) {\n            let key, value;\n            if (isPair(pair)) {\n                key = toJS(pair.key, '', ctx);\n                value = toJS(pair.value, key, ctx);\n            }\n            else {\n                key = toJS(pair, '', ctx);\n            }\n            if (map.has(key))\n                throw new Error('Ordered maps must not include duplicate keys');\n            map.set(key, value);\n        }\n        return map;\n    }\n}\nYAMLOMap.tag = 'tag:yaml.org,2002:omap';\nconst omap = {\n    collection: 'seq',\n    identify: value => value instanceof Map,\n    nodeClass: YAMLOMap,\n    default: false,\n    tag: 'tag:yaml.org,2002:omap',\n    resolve(seq, onError) {\n        const pairs = resolvePairs(seq, onError);\n        const seenKeys = [];\n        for (const { key } of pairs.items) {\n            if (isScalar(key)) {\n                if (seenKeys.includes(key.value)) {\n                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);\n                }\n                else {\n                    seenKeys.push(key.value);\n                }\n            }\n        }\n        return Object.assign(new YAMLOMap(), pairs);\n    },\n    createNode(schema, iterable, ctx) {\n        const pairs = createPairs(schema, iterable, ctx);\n        const omap = new YAMLOMap();\n        omap.items = pairs.items;\n        return omap;\n    }\n};\n\nexport { YAMLOMap, omap };\n","import { Scalar } from '../../nodes/Scalar.js';\n\nfunction boolStringify({ value, source }, ctx) {\n    const boolObj = value ? trueTag : falseTag;\n    if (source && boolObj.test.test(source))\n        return source;\n    return value ? ctx.options.trueStr : ctx.options.falseStr;\n}\nconst trueTag = {\n    identify: value => value === true,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n    resolve: () => new Scalar(true),\n    stringify: boolStringify\n};\nconst falseTag = {\n    identify: value => value === false,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,\n    resolve: () => new Scalar(false),\n    stringify: boolStringify\n};\n\nexport { falseTag, trueTag };\n","import { Scalar } from '../../nodes/Scalar.js';\nimport { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\nconst floatNaN = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?\\.(?:inf|Inf|INF|nan|NaN|NAN)$/,\n    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber\n};\nconst floatExp = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n    resolve: (str) => parseFloat(str.replace(/_/g, '')),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber(node);\n    }\n};\nconst float = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:[0-9][0-9_]*)?\\.[0-9_]*$/,\n    resolve(str) {\n        const node = new Scalar(parseFloat(str.replace(/_/g, '')));\n        const dot = str.indexOf('.');\n        if (dot !== -1) {\n            const f = str.substring(dot + 1).replace(/_/g, '');\n            if (f[f.length - 1] === '0')\n                node.minFractionDigits = f.length;\n        }\n        return node;\n    },\n    stringify: stringifyNumber\n};\n\nexport { float, floatExp, floatNaN };\n","import { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\nfunction intResolve(str, offset, radix, { intAsBigInt }) {\n    const sign = str[0];\n    if (sign === '-' || sign === '+')\n        offset += 1;\n    str = str.substring(offset).replace(/_/g, '');\n    if (intAsBigInt) {\n        switch (radix) {\n            case 2:\n                str = `0b${str}`;\n                break;\n            case 8:\n                str = `0o${str}`;\n                break;\n            case 16:\n                str = `0x${str}`;\n                break;\n        }\n        const n = BigInt(str);\n        return sign === '-' ? BigInt(-1) * n : n;\n    }\n    const n = parseInt(str, radix);\n    return sign === '-' ? -1 * n : n;\n}\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value)) {\n        const str = value.toString(radix);\n        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n    }\n    return stringifyNumber(node);\n}\nconst intBin = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'BIN',\n    test: /^[-+]?0b[0-1_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),\n    stringify: node => intStringify(node, 2, '0b')\n};\nconst intOct = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^[-+]?0[0-7_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),\n    stringify: node => intStringify(node, 8, '0')\n};\nconst int = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9][0-9_]*$/,\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\n    stringify: stringifyNumber\n};\nconst intHex = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^[-+]?0x[0-9a-fA-F_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\n    stringify: node => intStringify(node, 16, '0x')\n};\n\nexport { int, intBin, intHex, intOct };\n","import { isMap, isPair, isScalar } from '../../nodes/Node.js';\nimport { createPair, Pair } from '../../nodes/Pair.js';\nimport { YAMLMap, findPair } from '../../nodes/YAMLMap.js';\n\nclass YAMLSet extends YAMLMap {\n    constructor(schema) {\n        super(schema);\n        this.tag = YAMLSet.tag;\n    }\n    add(key) {\n        let pair;\n        if (isPair(key))\n            pair = key;\n        else if (typeof key === 'object' &&\n            'key' in key &&\n            'value' in key &&\n            key.value === null)\n            pair = new Pair(key.key, null);\n        else\n            pair = new Pair(key, null);\n        const prev = findPair(this.items, pair.key);\n        if (!prev)\n            this.items.push(pair);\n    }\n    /**\n     * If `keepPair` is `true`, returns the Pair matching `key`.\n     * Otherwise, returns the value of that Pair's key.\n     */\n    get(key, keepPair) {\n        const pair = findPair(this.items, key);\n        return !keepPair && isPair(pair)\n            ? isScalar(pair.key)\n                ? pair.key.value\n                : pair.key\n            : pair;\n    }\n    set(key, value) {\n        if (typeof value !== 'boolean')\n            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);\n        const prev = findPair(this.items, key);\n        if (prev && !value) {\n            this.items.splice(this.items.indexOf(prev), 1);\n        }\n        else if (!prev && value) {\n            this.items.push(new Pair(key));\n        }\n    }\n    toJSON(_, ctx) {\n        return super.toJSON(_, ctx, Set);\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        if (this.hasAllNullValues(true))\n            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);\n        else\n            throw new Error('Set items must all have null values');\n    }\n}\nYAMLSet.tag = 'tag:yaml.org,2002:set';\nconst set = {\n    collection: 'map',\n    identify: value => value instanceof Set,\n    nodeClass: YAMLSet,\n    default: false,\n    tag: 'tag:yaml.org,2002:set',\n    resolve(map, onError) {\n        if (isMap(map)) {\n            if (map.hasAllNullValues(true))\n                return Object.assign(new YAMLSet(), map);\n            else\n                onError('Set items must all have null values');\n        }\n        else\n            onError('Expected a mapping for this tag');\n        return map;\n    },\n    createNode(schema, iterable, ctx) {\n        const { replacer } = ctx;\n        const set = new YAMLSet(schema);\n        if (iterable && Symbol.iterator in Object(iterable))\n            for (let value of iterable) {\n                if (typeof replacer === 'function')\n                    value = replacer.call(iterable, value, value);\n                set.items.push(createPair(value, null, ctx));\n            }\n        return set;\n    }\n};\n\nexport { YAMLSet, set };\n","import { stringifyNumber } from '../../stringify/stringifyNumber.js';\n\n/** Internal types handle bigint as number, because TS can't figure it out. */\nfunction parseSexagesimal(str, asBigInt) {\n    const sign = str[0];\n    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;\n    const num = (n) => asBigInt ? BigInt(n) : Number(n);\n    const res = parts\n        .replace(/_/g, '')\n        .split(':')\n        .reduce((res, p) => res * num(60) + num(p), num(0));\n    return (sign === '-' ? num(-1) * res : res);\n}\n/**\n * hhhh:mm:ss.sss\n *\n * Internal types handle bigint as number, because TS can't figure it out.\n */\nfunction stringifySexagesimal(node) {\n    let { value } = node;\n    let num = (n) => n;\n    if (typeof value === 'bigint')\n        num = n => BigInt(n);\n    else if (isNaN(value) || !isFinite(value))\n        return stringifyNumber(node);\n    let sign = '';\n    if (value < 0) {\n        sign = '-';\n        value *= num(-1);\n    }\n    const _60 = num(60);\n    const parts = [value % _60]; // seconds, including ms\n    if (value < 60) {\n        parts.unshift(0); // at least one : is required\n    }\n    else {\n        value = (value - parts[0]) / _60;\n        parts.unshift(value % _60); // minutes\n        if (value >= 60) {\n            value = (value - parts[0]) / _60;\n            parts.unshift(value); // hours\n        }\n    }\n    return (sign +\n        parts\n            .map(n => (n < 10 ? '0' + String(n) : String(n)))\n            .join(':')\n            .replace(/000000\\d*$/, '') // % 60 may introduce error\n    );\n}\nconst intTime = {\n    identify: value => typeof value === 'bigint' || Number.isInteger(value),\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,\n    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),\n    stringify: stringifySexagesimal\n};\nconst floatTime = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*$/,\n    resolve: str => parseSexagesimal(str, false),\n    stringify: stringifySexagesimal\n};\nconst timestamp = {\n    identify: value => value instanceof Date,\n    default: true,\n    tag: 'tag:yaml.org,2002:timestamp',\n    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n    // may be omitted altogether, resulting in a date format. In such a case, the time part is\n    // assumed to be 00:00:00Z (start of day, UTC).\n    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n        '(?:' + // time is optional\n        '(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n        '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n        ')?$'),\n    resolve(str) {\n        const match = str.match(timestamp.test);\n        if (!match)\n            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');\n        const [, year, month, day, hour, minute, second] = match.map(Number);\n        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;\n        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);\n        const tz = match[8];\n        if (tz && tz !== 'Z') {\n            let d = parseSexagesimal(tz, false);\n            if (Math.abs(d) < 30)\n                d *= 60;\n            date -= 60000 * d;\n        }\n        return new Date(date);\n    },\n    stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\\.000Z$/, '')\n};\n\nexport { floatTime, intTime, timestamp };\n","import { map } from '../common/map.js';\nimport { nullTag } from '../common/null.js';\nimport { seq } from '../common/seq.js';\nimport { string } from '../common/string.js';\nimport { binary } from './binary.js';\nimport { trueTag, falseTag } from './bool.js';\nimport { floatNaN, floatExp, float } from './float.js';\nimport { intBin, intOct, int, intHex } from './int.js';\nimport { omap } from './omap.js';\nimport { pairs } from './pairs.js';\nimport { set } from './set.js';\nimport { intTime, floatTime, timestamp } from './timestamp.js';\n\nconst schema = [\n    map,\n    seq,\n    string,\n    nullTag,\n    trueTag,\n    falseTag,\n    intBin,\n    intOct,\n    int,\n    intHex,\n    floatNaN,\n    floatExp,\n    float,\n    binary,\n    omap,\n    pairs,\n    set,\n    intTime,\n    floatTime,\n    timestamp\n];\n\nexport { schema };\n","import { map } from './common/map.js';\nimport { nullTag } from './common/null.js';\nimport { seq } from './common/seq.js';\nimport { string } from './common/string.js';\nimport { boolTag } from './core/bool.js';\nimport { float, floatExp, floatNaN } from './core/float.js';\nimport { int, intHex, intOct } from './core/int.js';\nimport { schema } from './core/schema.js';\nimport { schema as schema$1 } from './json/schema.js';\nimport { binary } from './yaml-1.1/binary.js';\nimport { omap } from './yaml-1.1/omap.js';\nimport { pairs } from './yaml-1.1/pairs.js';\nimport { schema as schema$2 } from './yaml-1.1/schema.js';\nimport { set } from './yaml-1.1/set.js';\nimport { floatTime, intTime, timestamp } from './yaml-1.1/timestamp.js';\n\nconst schemas = new Map([\n    ['core', schema],\n    ['failsafe', [map, seq, string]],\n    ['json', schema$1],\n    ['yaml11', schema$2],\n    ['yaml-1.1', schema$2]\n]);\nconst tagsByName = {\n    binary,\n    bool: boolTag,\n    float,\n    floatExp,\n    floatNaN,\n    floatTime,\n    int,\n    intHex,\n    intOct,\n    intTime,\n    map,\n    null: nullTag,\n    omap,\n    pairs,\n    seq,\n    set,\n    timestamp\n};\nconst coreKnownTags = {\n    'tag:yaml.org,2002:binary': binary,\n    'tag:yaml.org,2002:omap': omap,\n    'tag:yaml.org,2002:pairs': pairs,\n    'tag:yaml.org,2002:set': set,\n    'tag:yaml.org,2002:timestamp': timestamp\n};\nfunction getTags(customTags, schemaName) {\n    let tags = schemas.get(schemaName);\n    if (!tags) {\n        if (Array.isArray(customTags))\n            tags = [];\n        else {\n            const keys = Array.from(schemas.keys())\n                .filter(key => key !== 'yaml11')\n                .map(key => JSON.stringify(key))\n                .join(', ');\n            throw new Error(`Unknown schema \"${schemaName}\"; use one of ${keys} or define customTags array`);\n        }\n    }\n    if (Array.isArray(customTags)) {\n        for (const tag of customTags)\n            tags = tags.concat(tag);\n    }\n    else if (typeof customTags === 'function') {\n        tags = customTags(tags.slice());\n    }\n    return tags.map(tag => {\n        if (typeof tag !== 'string')\n            return tag;\n        const tagObj = tagsByName[tag];\n        if (tagObj)\n            return tagObj;\n        const keys = Object.keys(tagsByName)\n            .map(key => JSON.stringify(key))\n            .join(', ');\n        throw new Error(`Unknown custom tag \"${tag}\"; use one of ${keys}`);\n    });\n}\n\nexport { coreKnownTags, getTags };\n","import { MAP, SCALAR, SEQ } from '../nodes/Node.js';\nimport { map } from './common/map.js';\nimport { seq } from './common/seq.js';\nimport { string } from './common/string.js';\nimport { getTags, coreKnownTags } from './tags.js';\n\nconst sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\nclass Schema {\n    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {\n        this.compat = Array.isArray(compat)\n            ? getTags(compat, 'compat')\n            : compat\n                ? getTags(null, compat)\n                : null;\n        this.merge = !!merge;\n        this.name = (typeof schema === 'string' && schema) || 'core';\n        this.knownTags = resolveKnownTags ? coreKnownTags : {};\n        this.tags = getTags(customTags, this.name);\n        this.toStringOptions = toStringDefaults ?? null;\n        Object.defineProperty(this, MAP, { value: map });\n        Object.defineProperty(this, SCALAR, { value: string });\n        Object.defineProperty(this, SEQ, { value: seq });\n        // Used by createMap()\n        this.sortMapEntries =\n            typeof sortMapEntries === 'function'\n                ? sortMapEntries\n                : sortMapEntries === true\n                    ? sortMapEntriesByKey\n                    : null;\n    }\n    clone() {\n        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));\n        copy.tags = this.tags.slice();\n        return copy;\n    }\n}\n\nexport { Schema };\n","/**\n * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,\n * in section 24.5.1.1 \"Runtime Semantics: InternalizeJSONProperty\" of the\n * 2021 edition: https://tc39.es/ecma262/#sec-json.parse\n *\n * Includes extensions for handling Map and Set objects.\n */\nfunction applyReviver(reviver, obj, key, val) {\n    if (val && typeof val === 'object') {\n        if (Array.isArray(val)) {\n            for (let i = 0, len = val.length; i < len; ++i) {\n                const v0 = val[i];\n                const v1 = applyReviver(reviver, val, String(i), v0);\n                if (v1 === undefined)\n                    delete val[i];\n                else if (v1 !== v0)\n                    val[i] = v1;\n            }\n        }\n        else if (val instanceof Map) {\n            for (const k of Array.from(val.keys())) {\n                const v0 = val.get(k);\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined)\n                    val.delete(k);\n                else if (v1 !== v0)\n                    val.set(k, v1);\n            }\n        }\n        else if (val instanceof Set) {\n            for (const v0 of Array.from(val)) {\n                const v1 = applyReviver(reviver, val, v0, v0);\n                if (v1 === undefined)\n                    val.delete(v0);\n                else if (v1 !== v0) {\n                    val.delete(v0);\n                    val.add(v1);\n                }\n            }\n        }\n        else {\n            for (const [k, v0] of Object.entries(val)) {\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined)\n                    delete val[k];\n                else if (v1 !== v0)\n                    val[k] = v1;\n            }\n        }\n    }\n    return reviver.call(obj, key, val);\n}\n\nexport { applyReviver };\n","import { Alias } from '../nodes/Alias.js';\nimport { isEmptyPath, collectionFromPath } from '../nodes/Collection.js';\nimport { NODE_TYPE, DOC, isNode, isCollection, isScalar } from '../nodes/Node.js';\nimport { Pair } from '../nodes/Pair.js';\nimport { toJS } from '../nodes/toJS.js';\nimport { Schema } from '../schema/Schema.js';\nimport { stringify } from '../stringify/stringify.js';\nimport { stringifyDocument } from '../stringify/stringifyDocument.js';\nimport { anchorNames, findNewAnchor, createNodeAnchors } from './anchors.js';\nimport { applyReviver } from './applyReviver.js';\nimport { createNode } from './createNode.js';\nimport { Directives } from './directives.js';\n\nclass Document {\n    constructor(value, replacer, options) {\n        /** A comment before this Document */\n        this.commentBefore = null;\n        /** A comment immediately after this Document */\n        this.comment = null;\n        /** Errors encountered during parsing. */\n        this.errors = [];\n        /** Warnings encountered during parsing. */\n        this.warnings = [];\n        Object.defineProperty(this, NODE_TYPE, { value: DOC });\n        let _replacer = null;\n        if (typeof replacer === 'function' || Array.isArray(replacer)) {\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const opt = Object.assign({\n            intAsBigInt: false,\n            keepSourceTokens: false,\n            logLevel: 'warn',\n            prettyErrors: true,\n            strict: true,\n            uniqueKeys: true,\n            version: '1.2'\n        }, options);\n        this.options = opt;\n        let { version } = opt;\n        if (options?._directives) {\n            this.directives = options._directives.atDocument();\n            if (this.directives.yaml.explicit)\n                version = this.directives.yaml.version;\n        }\n        else\n            this.directives = new Directives({ version });\n        this.setSchema(version, options);\n        if (value === undefined)\n            this.contents = null;\n        else {\n            this.contents = this.createNode(value, _replacer, options);\n        }\n    }\n    /**\n     * Create a deep copy of this Document and its contents.\n     *\n     * Custom Node values that inherit from `Object` still refer to their original instances.\n     */\n    clone() {\n        const copy = Object.create(Document.prototype, {\n            [NODE_TYPE]: { value: DOC }\n        });\n        copy.commentBefore = this.commentBefore;\n        copy.comment = this.comment;\n        copy.errors = this.errors.slice();\n        copy.warnings = this.warnings.slice();\n        copy.options = Object.assign({}, this.options);\n        if (this.directives)\n            copy.directives = this.directives.clone();\n        copy.schema = this.schema.clone();\n        copy.contents = isNode(this.contents)\n            ? this.contents.clone(copy.schema)\n            : this.contents;\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /** Adds a value to the document. */\n    add(value) {\n        if (assertCollection(this.contents))\n            this.contents.add(value);\n    }\n    /** Adds a value to the document. */\n    addIn(path, value) {\n        if (assertCollection(this.contents))\n            this.contents.addIn(path, value);\n    }\n    /**\n     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.\n     *\n     * If `node` already has an anchor, `name` is ignored.\n     * Otherwise, the `node.anchor` value will be set to `name`,\n     * or if an anchor with that name is already present in the document,\n     * `name` will be used as a prefix for a new unique anchor.\n     * If `name` is undefined, the generated anchor will use 'a' as a prefix.\n     */\n    createAlias(node, name) {\n        if (!node.anchor) {\n            const prev = anchorNames(this);\n            node.anchor =\n                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n                !name || prev.has(name) ? findNewAnchor(name || 'a', prev) : name;\n        }\n        return new Alias(node.anchor);\n    }\n    createNode(value, replacer, options) {\n        let _replacer = undefined;\n        if (typeof replacer === 'function') {\n            value = replacer.call({ '': value }, '', value);\n            _replacer = replacer;\n        }\n        else if (Array.isArray(replacer)) {\n            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;\n            const asStr = replacer.filter(keyToStr).map(String);\n            if (asStr.length > 0)\n                replacer = replacer.concat(asStr);\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};\n        const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, \n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        anchorPrefix || 'a');\n        const ctx = {\n            aliasDuplicateObjects: aliasDuplicateObjects ?? true,\n            keepUndefined: keepUndefined ?? false,\n            onAnchor,\n            onTagObj,\n            replacer: _replacer,\n            schema: this.schema,\n            sourceObjects\n        };\n        const node = createNode(value, tag, ctx);\n        if (flow && isCollection(node))\n            node.flow = true;\n        setAnchors();\n        return node;\n    }\n    /**\n     * Convert a key and a value into a `Pair` using the current schema,\n     * recursively wrapping all values as `Scalar` or `Collection` nodes.\n     */\n    createPair(key, value, options = {}) {\n        const k = this.createNode(key, null, options);\n        const v = this.createNode(value, null, options);\n        return new Pair(k, v);\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key) {\n        return assertCollection(this.contents) ? this.contents.delete(key) : false;\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        if (isEmptyPath(path)) {\n            if (this.contents == null)\n                return false;\n            this.contents = null;\n            return true;\n        }\n        return assertCollection(this.contents)\n            ? this.contents.deleteIn(path)\n            : false;\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    get(key, keepScalar) {\n        return isCollection(this.contents)\n            ? this.contents.get(key, keepScalar)\n            : undefined;\n    }\n    /**\n     * Returns item at `path`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        if (isEmptyPath(path))\n            return !keepScalar && isScalar(this.contents)\n                ? this.contents.value\n                : this.contents;\n        return isCollection(this.contents)\n            ? this.contents.getIn(path, keepScalar)\n            : undefined;\n    }\n    /**\n     * Checks if the document includes a value with the key `key`.\n     */\n    has(key) {\n        return isCollection(this.contents) ? this.contents.has(key) : false;\n    }\n    /**\n     * Checks if the document includes a value at `path`.\n     */\n    hasIn(path) {\n        if (isEmptyPath(path))\n            return this.contents !== undefined;\n        return isCollection(this.contents) ? this.contents.hasIn(path) : false;\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    set(key, value) {\n        if (this.contents == null) {\n            this.contents = collectionFromPath(this.schema, [key], value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.set(key, value);\n        }\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        if (isEmptyPath(path))\n            this.contents = value;\n        else if (this.contents == null) {\n            this.contents = collectionFromPath(this.schema, Array.from(path), value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.setIn(path, value);\n        }\n    }\n    /**\n     * Change the YAML version and schema used by the document.\n     * A `null` version disables support for directives, explicit tags, anchors, and aliases.\n     * It also requires the `schema` option to be given as a `Schema` instance value.\n     *\n     * Overrides all previously set schema options.\n     */\n    setSchema(version, options = {}) {\n        if (typeof version === 'number')\n            version = String(version);\n        let opt;\n        switch (version) {\n            case '1.1':\n                if (this.directives)\n                    this.directives.yaml.version = '1.1';\n                else\n                    this.directives = new Directives({ version: '1.1' });\n                opt = { merge: true, resolveKnownTags: false, schema: 'yaml-1.1' };\n                break;\n            case '1.2':\n            case 'next':\n                if (this.directives)\n                    this.directives.yaml.version = version;\n                else\n                    this.directives = new Directives({ version });\n                opt = { merge: false, resolveKnownTags: true, schema: 'core' };\n                break;\n            case null:\n                if (this.directives)\n                    delete this.directives;\n                opt = null;\n                break;\n            default: {\n                const sv = JSON.stringify(version);\n                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);\n            }\n        }\n        // Not using `instanceof Schema` to allow for duck typing\n        if (options.schema instanceof Object)\n            this.schema = options.schema;\n        else if (opt)\n            this.schema = new Schema(Object.assign(opt, options));\n        else\n            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);\n    }\n    // json & jsonArg are only used from toJSON()\n    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {\n        const ctx = {\n            anchors: new Map(),\n            doc: this,\n            keep: !json,\n            mapAsMap: mapAsMap === true,\n            mapKeyWarned: false,\n            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100,\n            stringify\n        };\n        const res = toJS(this.contents, jsonArg ?? '', ctx);\n        if (typeof onAnchor === 'function')\n            for (const { count, res } of ctx.anchors.values())\n                onAnchor(res, count);\n        return typeof reviver === 'function'\n            ? applyReviver(reviver, { '': res }, '', res)\n            : res;\n    }\n    /**\n     * A JSON representation of the document `contents`.\n     *\n     * @param jsonArg Used by `JSON.stringify` to indicate the array index or\n     *   property name.\n     */\n    toJSON(jsonArg, onAnchor) {\n        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });\n    }\n    /** A YAML representation of the document. */\n    toString(options = {}) {\n        if (this.errors.length > 0)\n            throw new Error('Document with errors cannot be stringified');\n        if ('indent' in options &&\n            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {\n            const s = JSON.stringify(options.indent);\n            throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n        }\n        return stringifyDocument(this, options);\n    }\n}\nfunction assertCollection(contents) {\n    if (isCollection(contents))\n        return true;\n    throw new Error('Expected a YAML collection as document contents');\n}\n\nexport { Document };\n","import { isNode } from '../nodes/Node.js';\nimport { createStringifyContext, stringify } from './stringify.js';\nimport { indentComment, lineComment } from './stringifyComment.js';\n\nfunction stringifyDocument(doc, options) {\n    const lines = [];\n    let hasDirectives = options.directives === true;\n    if (options.directives !== false && doc.directives) {\n        const dir = doc.directives.toString(doc);\n        if (dir) {\n            lines.push(dir);\n            hasDirectives = true;\n        }\n        else if (doc.directives.docStart)\n            hasDirectives = true;\n    }\n    if (hasDirectives)\n        lines.push('---');\n    const ctx = createStringifyContext(doc, options);\n    const { commentString } = ctx.options;\n    if (doc.commentBefore) {\n        if (lines.length !== 1)\n            lines.unshift('');\n        const cs = commentString(doc.commentBefore);\n        lines.unshift(indentComment(cs, ''));\n    }\n    let chompKeep = false;\n    let contentComment = null;\n    if (doc.contents) {\n        if (isNode(doc.contents)) {\n            if (doc.contents.spaceBefore && hasDirectives)\n                lines.push('');\n            if (doc.contents.commentBefore) {\n                const cs = commentString(doc.contents.commentBefore);\n                lines.push(indentComment(cs, ''));\n            }\n            // top-level block scalars need to be indented if followed by a comment\n            ctx.forceBlockIndent = !!doc.comment;\n            contentComment = doc.contents.comment;\n        }\n        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);\n        let body = stringify(doc.contents, ctx, () => (contentComment = null), onChompKeep);\n        if (contentComment)\n            body += lineComment(body, '', commentString(contentComment));\n        if ((body[0] === '|' || body[0] === '>') &&\n            lines[lines.length - 1] === '---') {\n            // Top-level block scalars with a preceding doc marker ought to use the\n            // same line for their header.\n            lines[lines.length - 1] = `--- ${body}`;\n        }\n        else\n            lines.push(body);\n    }\n    else {\n        lines.push(stringify(doc.contents, ctx));\n    }\n    if (doc.directives?.docEnd) {\n        if (doc.comment) {\n            const cs = commentString(doc.comment);\n            if (cs.includes('\\n')) {\n                lines.push('...');\n                lines.push(indentComment(cs, ''));\n            }\n            else {\n                lines.push(`... ${cs}`);\n            }\n        }\n        else {\n            lines.push('...');\n        }\n    }\n    else {\n        let dc = doc.comment;\n        if (dc && chompKeep)\n            dc = dc.replace(/^\\n+/, '');\n        if (dc) {\n            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')\n                lines.push('');\n            lines.push(indentComment(commentString(dc), ''));\n        }\n    }\n    return lines.join('\\n') + '\\n';\n}\n\nexport { stringifyDocument };\n","class YAMLError extends Error {\n    constructor(name, pos, code, message) {\n        super();\n        this.name = name;\n        this.code = code;\n        this.message = message;\n        this.pos = pos;\n    }\n}\nclass YAMLParseError extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLParseError', pos, code, message);\n    }\n}\nclass YAMLWarning extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLWarning', pos, code, message);\n    }\n}\nconst prettifyError = (src, lc) => (error) => {\n    if (error.pos[0] === -1)\n        return;\n    error.linePos = error.pos.map(pos => lc.linePos(pos));\n    const { line, col } = error.linePos[0];\n    error.message += ` at line ${line}, column ${col}`;\n    let ci = col - 1;\n    let lineStr = src\n        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])\n        .replace(/[\\n\\r]+$/, '');\n    // Trim to max 80 chars, keeping col position near the middle\n    if (ci >= 60 && lineStr.length > 80) {\n        const trimStart = Math.min(ci - 39, lineStr.length - 79);\n        lineStr = '…' + lineStr.substring(trimStart);\n        ci -= trimStart - 1;\n    }\n    if (lineStr.length > 80)\n        lineStr = lineStr.substring(0, 79) + '…';\n    // Include previous line in context if pointing at line start\n    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {\n        // Regexp won't match if start is trimmed\n        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);\n        if (prev.length > 80)\n            prev = prev.substring(0, 79) + '…\\n';\n        lineStr = prev + lineStr;\n    }\n    if (/[^ ]/.test(lineStr)) {\n        let count = 1;\n        const end = error.linePos[1];\n        if (end && end.line === line && end.col > col) {\n            count = Math.min(end.col - col, 80 - ci);\n        }\n        const pointer = ' '.repeat(ci) + '^'.repeat(count);\n        error.message += `:\\n\\n${lineStr}\\n${pointer}\\n`;\n    }\n};\n\nexport { YAMLError, YAMLParseError, YAMLWarning, prettifyError };\n","function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {\n    let spaceBefore = false;\n    let atNewline = startOnNewline;\n    let hasSpace = startOnNewline;\n    let comment = '';\n    let commentSep = '';\n    let hasNewline = false;\n    let hasNewlineAfterProp = false;\n    let reqSpace = false;\n    let anchor = null;\n    let tag = null;\n    let comma = null;\n    let found = null;\n    let start = null;\n    for (const token of tokens) {\n        if (reqSpace) {\n            if (token.type !== 'space' &&\n                token.type !== 'newline' &&\n                token.type !== 'comma')\n                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n            reqSpace = false;\n        }\n        switch (token.type) {\n            case 'space':\n                // At the doc level, tabs at line start may be parsed\n                // as leading white space rather than indentation.\n                // In a flow collection, only the parser handles indent.\n                if (!flow &&\n                    atNewline &&\n                    indicator !== 'doc-start' &&\n                    token.source[0] === '\\t')\n                    onError(token, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n                hasSpace = true;\n                break;\n            case 'comment': {\n                if (!hasSpace)\n                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                const cb = token.source.substring(1) || ' ';\n                if (!comment)\n                    comment = cb;\n                else\n                    comment += commentSep + cb;\n                commentSep = '';\n                atNewline = false;\n                break;\n            }\n            case 'newline':\n                if (atNewline) {\n                    if (comment)\n                        comment += token.source;\n                    else\n                        spaceBefore = true;\n                }\n                else\n                    commentSep += token.source;\n                atNewline = true;\n                hasNewline = true;\n                if (anchor || tag)\n                    hasNewlineAfterProp = true;\n                hasSpace = true;\n                break;\n            case 'anchor':\n                if (anchor)\n                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');\n                if (token.source.endsWith(':'))\n                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);\n                anchor = token;\n                if (start === null)\n                    start = token.offset;\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            case 'tag': {\n                if (tag)\n                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');\n                tag = token;\n                if (start === null)\n                    start = token.offset;\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            }\n            case indicator:\n                // Could here handle preceding comments differently\n                if (anchor || tag)\n                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);\n                if (found)\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);\n                found = token;\n                atNewline = false;\n                hasSpace = false;\n                break;\n            case 'comma':\n                if (flow) {\n                    if (comma)\n                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);\n                    comma = token;\n                    atNewline = false;\n                    hasSpace = false;\n                    break;\n                }\n            // else fallthrough\n            default:\n                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);\n                atNewline = false;\n                hasSpace = false;\n        }\n    }\n    const last = tokens[tokens.length - 1];\n    const end = last ? last.offset + last.source.length : offset;\n    if (reqSpace &&\n        next &&\n        next.type !== 'space' &&\n        next.type !== 'newline' &&\n        next.type !== 'comma' &&\n        (next.type !== 'scalar' || next.source !== ''))\n        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n    return {\n        comma,\n        found,\n        spaceBefore,\n        comment,\n        hasNewline,\n        hasNewlineAfterProp,\n        anchor,\n        tag,\n        end,\n        start: start ?? end\n    };\n}\n\nexport { resolveProps };\n","function containsNewline(key) {\n    if (!key)\n        return null;\n    switch (key.type) {\n        case 'alias':\n        case 'scalar':\n        case 'double-quoted-scalar':\n        case 'single-quoted-scalar':\n            if (key.source.includes('\\n'))\n                return true;\n            if (key.end)\n                for (const st of key.end)\n                    if (st.type === 'newline')\n                        return true;\n            return false;\n        case 'flow-collection':\n            for (const it of key.items) {\n                for (const st of it.start)\n                    if (st.type === 'newline')\n                        return true;\n                if (it.sep)\n                    for (const st of it.sep)\n                        if (st.type === 'newline')\n                            return true;\n                if (containsNewline(it.key) || containsNewline(it.value))\n                    return true;\n            }\n            return false;\n        default:\n            return true;\n    }\n}\n\nexport { containsNewline };\n","import { containsNewline } from './util-contains-newline.js';\n\nfunction flowIndentCheck(indent, fc, onError) {\n    if (fc?.type === 'flow-collection') {\n        const end = fc.end[0];\n        if (end.indent === indent &&\n            (end.source === ']' || end.source === '}') &&\n            containsNewline(fc)) {\n            const msg = 'Flow end indicator should be more indented than parent';\n            onError(end, 'BAD_INDENT', msg, true);\n        }\n    }\n}\n\nexport { flowIndentCheck };\n","import { isScalar } from '../nodes/Node.js';\n\nfunction mapIncludes(ctx, items, search) {\n    const { uniqueKeys } = ctx.options;\n    if (uniqueKeys === false)\n        return false;\n    const isEqual = typeof uniqueKeys === 'function'\n        ? uniqueKeys\n        : (a, b) => a === b ||\n            (isScalar(a) &&\n                isScalar(b) &&\n                a.value === b.value &&\n                !(a.value === '<<' && ctx.schema.merge));\n    return items.some(pair => isEqual(pair.key, search));\n}\n\nexport { mapIncludes };\n","import { Pair } from '../nodes/Pair.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { resolveProps } from './resolve-props.js';\nimport { containsNewline } from './util-contains-newline.js';\nimport { flowIndentCheck } from './util-flow-indent-check.js';\nimport { mapIncludes } from './util-map-includes.js';\n\nconst startColMsg = 'All mapping items must start at the same column';\nfunction resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError) {\n    const map = new YAMLMap(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    let offset = bm.offset;\n    for (const collItem of bm.items) {\n        const { start, key, sep, value } = collItem;\n        // key properties\n        const keyProps = resolveProps(start, {\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            startOnNewline: true\n        });\n        const implicitKey = !keyProps.found;\n        if (implicitKey) {\n            if (key) {\n                if (key.type === 'block-seq')\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');\n                else if ('indent' in key && key.indent !== bm.indent)\n                    onError(offset, 'BAD_INDENT', startColMsg);\n            }\n            if (!keyProps.anchor && !keyProps.tag && !sep) {\n                // TODO: assert being at last item?\n                if (keyProps.comment) {\n                    if (map.comment)\n                        map.comment += '\\n' + keyProps.comment;\n                    else\n                        map.comment = keyProps.comment;\n                }\n                continue;\n            }\n            if (keyProps.hasNewlineAfterProp || containsNewline(key)) {\n                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');\n            }\n        }\n        else if (keyProps.found?.indent !== bm.indent) {\n            onError(offset, 'BAD_INDENT', startColMsg);\n        }\n        // key value\n        const keyStart = keyProps.end;\n        const keyNode = key\n            ? composeNode(ctx, key, keyProps, onError)\n            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);\n        if (ctx.schema.compat)\n            flowIndentCheck(bm.indent, key, onError);\n        if (mapIncludes(ctx, map.items, keyNode))\n            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n        // value properties\n        const valueProps = resolveProps(sep ?? [], {\n            indicator: 'map-value-ind',\n            next: value,\n            offset: keyNode.range[2],\n            onError,\n            startOnNewline: !key || key.type === 'block-scalar'\n        });\n        offset = valueProps.end;\n        if (valueProps.found) {\n            if (implicitKey) {\n                if (value?.type === 'block-map' && !valueProps.hasNewline)\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');\n                if (ctx.options.strict &&\n                    keyProps.start < valueProps.found.offset - 1024)\n                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);\n            if (ctx.schema.compat)\n                flowIndentCheck(bm.indent, value, onError);\n            offset = valueNode.range[2];\n            const pair = new Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n        else {\n            // key with no value\n            if (implicitKey)\n                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');\n            if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair(keyNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n    }\n    map.range = [bm.offset, offset, offset];\n    return map;\n}\n\nexport { resolveBlockMap };\n","function resolveEnd(end, offset, reqSpace, onError) {\n    let comment = '';\n    if (end) {\n        let hasSpace = false;\n        let sep = '';\n        for (const token of end) {\n            const { source, type } = token;\n            switch (type) {\n                case 'space':\n                    hasSpace = true;\n                    break;\n                case 'comment': {\n                    if (reqSpace && !hasSpace)\n                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                    const cb = source.substring(1) || ' ';\n                    if (!comment)\n                        comment = cb;\n                    else\n                        comment += sep + cb;\n                    sep = '';\n                    break;\n                }\n                case 'newline':\n                    if (comment)\n                        sep += source;\n                    hasSpace = true;\n                    break;\n                default:\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);\n            }\n            offset += source.length;\n        }\n    }\n    return { comment, offset };\n}\n\nexport { resolveEnd };\n","import { isPair } from '../nodes/Node.js';\nimport { Pair } from '../nodes/Pair.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveEnd } from './resolve-end.js';\nimport { resolveProps } from './resolve-props.js';\nimport { containsNewline } from './util-contains-newline.js';\nimport { mapIncludes } from './util-map-includes.js';\n\nconst blockMsg = 'Block collections are not allowed within flow collections';\nconst isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');\nfunction resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError) {\n    const isMap = fc.start.source === '{';\n    const fcName = isMap ? 'flow map' : 'flow sequence';\n    const coll = isMap\n        ? new YAMLMap(ctx.schema)\n        : new YAMLSeq(ctx.schema);\n    coll.flow = true;\n    const atRoot = ctx.atRoot;\n    if (atRoot)\n        ctx.atRoot = false;\n    let offset = fc.offset + fc.start.source.length;\n    for (let i = 0; i < fc.items.length; ++i) {\n        const collItem = fc.items[i];\n        const { start, key, sep, value } = collItem;\n        const props = resolveProps(start, {\n            flow: fcName,\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            startOnNewline: false\n        });\n        if (!props.found) {\n            if (!props.anchor && !props.tag && !sep && !value) {\n                if (i === 0 && props.comma)\n                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n                else if (i < fc.items.length - 1)\n                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);\n                if (props.comment) {\n                    if (coll.comment)\n                        coll.comment += '\\n' + props.comment;\n                    else\n                        coll.comment = props.comment;\n                }\n                offset = props.end;\n                continue;\n            }\n            if (!isMap && ctx.options.strict && containsNewline(key))\n                onError(key, // checked by containsNewline()\n                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n        }\n        if (i === 0) {\n            if (props.comma)\n                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n        }\n        else {\n            if (!props.comma)\n                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);\n            if (props.comment) {\n                let prevItemComment = '';\n                loop: for (const st of start) {\n                    switch (st.type) {\n                        case 'comma':\n                        case 'space':\n                            break;\n                        case 'comment':\n                            prevItemComment = st.source.substring(1);\n                            break loop;\n                        default:\n                            break loop;\n                    }\n                }\n                if (prevItemComment) {\n                    let prev = coll.items[coll.items.length - 1];\n                    if (isPair(prev))\n                        prev = prev.value ?? prev.key;\n                    if (prev.comment)\n                        prev.comment += '\\n' + prevItemComment;\n                    else\n                        prev.comment = prevItemComment;\n                    props.comment = props.comment.substring(prevItemComment.length + 1);\n                }\n            }\n        }\n        if (!isMap && !sep && !props.found) {\n            // item is a value in a seq\n            // → key & sep are empty, start does not include ? or :\n            const valueNode = value\n                ? composeNode(ctx, value, props, onError)\n                : composeEmptyNode(ctx, props.end, sep, null, props, onError);\n            coll.items.push(valueNode);\n            offset = valueNode.range[2];\n            if (isBlock(value))\n                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n        }\n        else {\n            // item is a key+value pair\n            // key value\n            const keyStart = props.end;\n            const keyNode = key\n                ? composeNode(ctx, key, props, onError)\n                : composeEmptyNode(ctx, keyStart, start, null, props, onError);\n            if (isBlock(key))\n                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            // value properties\n            const valueProps = resolveProps(sep ?? [], {\n                flow: fcName,\n                indicator: 'map-value-ind',\n                next: value,\n                offset: keyNode.range[2],\n                onError,\n                startOnNewline: false\n            });\n            if (valueProps.found) {\n                if (!isMap && !props.found && ctx.options.strict) {\n                    if (sep)\n                        for (const st of sep) {\n                            if (st === valueProps.found)\n                                break;\n                            if (st.type === 'newline') {\n                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n                                break;\n                            }\n                        }\n                    if (props.start < valueProps.found.offset - 1024)\n                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');\n                }\n            }\n            else if (value) {\n                if ('source' in value && value.source && value.source[0] === ':')\n                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);\n                else\n                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : valueProps.found\n                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)\n                    : null;\n            if (valueNode) {\n                if (isBlock(value))\n                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            }\n            else if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            if (isMap) {\n                const map = coll;\n                if (mapIncludes(ctx, map.items, keyNode))\n                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n                map.items.push(pair);\n            }\n            else {\n                const map = new YAMLMap(ctx.schema);\n                map.flow = true;\n                map.items.push(pair);\n                coll.items.push(map);\n            }\n            offset = valueNode ? valueNode.range[2] : valueProps.end;\n        }\n    }\n    const expectedEnd = isMap ? '}' : ']';\n    const [ce, ...ee] = fc.end;\n    let cePos = offset;\n    if (ce && ce.source === expectedEnd)\n        cePos = ce.offset + ce.source.length;\n    else {\n        const name = fcName[0].toUpperCase() + fcName.substring(1);\n        const msg = atRoot\n            ? `${name} must end with a ${expectedEnd}`\n            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;\n        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);\n        if (ce && ce.source.length !== 1)\n            ee.unshift(ce);\n    }\n    if (ee.length > 0) {\n        const end = resolveEnd(ee, cePos, ctx.options.strict, onError);\n        if (end.comment) {\n            if (coll.comment)\n                coll.comment += '\\n' + end.comment;\n            else\n                coll.comment = end.comment;\n        }\n        coll.range = [fc.offset, cePos, end.offset];\n    }\n    else {\n        coll.range = [fc.offset, cePos, cePos];\n    }\n    return coll;\n}\n\nexport { resolveFlowCollection };\n","import { isNode, isMap } from '../nodes/Node.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { resolveBlockMap } from './resolve-block-map.js';\nimport { resolveBlockSeq } from './resolve-block-seq.js';\nimport { resolveFlowCollection } from './resolve-flow-collection.js';\n\nfunction composeCollection(CN, ctx, token, tagToken, onError) {\n    let coll;\n    switch (token.type) {\n        case 'block-map': {\n            coll = resolveBlockMap(CN, ctx, token, onError);\n            break;\n        }\n        case 'block-seq': {\n            coll = resolveBlockSeq(CN, ctx, token, onError);\n            break;\n        }\n        case 'flow-collection': {\n            coll = resolveFlowCollection(CN, ctx, token, onError);\n            break;\n        }\n    }\n    if (!tagToken)\n        return coll;\n    const tagName = ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));\n    if (!tagName)\n        return coll;\n    // Cast needed due to: https://github.com/Microsoft/TypeScript/issues/3841\n    const Coll = coll.constructor;\n    if (tagName === '!' || tagName === Coll.tagName) {\n        coll.tag = Coll.tagName;\n        return coll;\n    }\n    const expType = isMap(coll) ? 'map' : 'seq';\n    let tag = ctx.schema.tags.find(t => t.collection === expType && t.tag === tagName);\n    if (!tag) {\n        const kt = ctx.schema.knownTags[tagName];\n        if (kt && kt.collection === expType) {\n            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));\n            tag = kt;\n        }\n        else {\n            onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);\n            coll.tag = tagName;\n            return coll;\n        }\n    }\n    const res = tag.resolve(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options);\n    const node = isNode(res)\n        ? res\n        : new Scalar(res);\n    node.range = coll.range;\n    node.tag = tagName;\n    if (tag?.format)\n        node.format = tag.format;\n    return node;\n}\n\nexport { composeCollection };\n","import { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveProps } from './resolve-props.js';\nimport { flowIndentCheck } from './util-flow-indent-check.js';\n\nfunction resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError) {\n    const seq = new YAMLSeq(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    let offset = bs.offset;\n    for (const { start, value } of bs.items) {\n        const props = resolveProps(start, {\n            indicator: 'seq-item-ind',\n            next: value,\n            offset,\n            onError,\n            startOnNewline: true\n        });\n        offset = props.end;\n        if (!props.found) {\n            if (props.anchor || props.tag || value) {\n                if (value && value.type === 'block-seq')\n                    onError(offset, 'BAD_INDENT', 'All sequence items must start at the same column');\n                else\n                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');\n            }\n            else {\n                // TODO: assert being at last item?\n                if (props.comment)\n                    seq.comment = props.comment;\n                continue;\n            }\n        }\n        const node = value\n            ? composeNode(ctx, value, props, onError)\n            : composeEmptyNode(ctx, offset, start, null, props, onError);\n        if (ctx.schema.compat)\n            flowIndentCheck(bs.indent, value, onError);\n        offset = node.range[2];\n        seq.items.push(node);\n    }\n    seq.range = [bs.offset, offset, offset];\n    return seq;\n}\n\nexport { resolveBlockSeq };\n","import { Scalar } from '../nodes/Scalar.js';\n\nfunction resolveBlockScalar(scalar, strict, onError) {\n    const start = scalar.offset;\n    const header = parseBlockScalarHeader(scalar, strict, onError);\n    if (!header)\n        return { value: '', type: null, comment: '', range: [start, start, start] };\n    const type = header.mode === '>' ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;\n    const lines = scalar.source ? splitLines(scalar.source) : [];\n    // determine the end of content & start of chomping\n    let chompStart = lines.length;\n    for (let i = lines.length - 1; i >= 0; --i) {\n        const content = lines[i][1];\n        if (content === '' || content === '\\r')\n            chompStart = i;\n        else\n            break;\n    }\n    // shortcut for empty contents\n    if (chompStart === 0) {\n        const value = header.chomp === '+' && lines.length > 0\n            ? '\\n'.repeat(Math.max(1, lines.length - 1))\n            : '';\n        let end = start + header.length;\n        if (scalar.source)\n            end += scalar.source.length;\n        return { value, type, comment: header.comment, range: [start, end, end] };\n    }\n    // find the indentation level to trim from start\n    let trimIndent = scalar.indent + header.indent;\n    let offset = scalar.offset + header.length;\n    let contentStart = 0;\n    for (let i = 0; i < chompStart; ++i) {\n        const [indent, content] = lines[i];\n        if (content === '' || content === '\\r') {\n            if (header.indent === 0 && indent.length > trimIndent)\n                trimIndent = indent.length;\n        }\n        else {\n            if (indent.length < trimIndent) {\n                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n                onError(offset + indent.length, 'MISSING_CHAR', message);\n            }\n            if (header.indent === 0)\n                trimIndent = indent.length;\n            contentStart = i;\n            break;\n        }\n        offset += indent.length + content.length + 1;\n    }\n    // include trailing more-indented empty lines in content\n    for (let i = lines.length - 1; i >= chompStart; --i) {\n        if (lines[i][0].length > trimIndent)\n            chompStart = i + 1;\n    }\n    let value = '';\n    let sep = '';\n    let prevMoreIndented = false;\n    // leading whitespace is kept intact\n    for (let i = 0; i < contentStart; ++i)\n        value += lines[i][0].slice(trimIndent) + '\\n';\n    for (let i = contentStart; i < chompStart; ++i) {\n        let [indent, content] = lines[i];\n        offset += indent.length + content.length + 1;\n        const crlf = content[content.length - 1] === '\\r';\n        if (crlf)\n            content = content.slice(0, -1);\n        /* istanbul ignore if already caught in lexer */\n        if (content && indent.length < trimIndent) {\n            const src = header.indent\n                ? 'explicit indentation indicator'\n                : 'first line';\n            const message = `Block scalar lines must not be less indented than their ${src}`;\n            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);\n            indent = '';\n        }\n        if (type === Scalar.BLOCK_LITERAL) {\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n        }\n        else if (indent.length > trimIndent || content[0] === '\\t') {\n            // more-indented content within a folded block\n            if (sep === ' ')\n                sep = '\\n';\n            else if (!prevMoreIndented && sep === '\\n')\n                sep = '\\n\\n';\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n            prevMoreIndented = true;\n        }\n        else if (content === '') {\n            // empty line\n            if (sep === '\\n')\n                value += '\\n';\n            else\n                sep = '\\n';\n        }\n        else {\n            value += sep + content;\n            sep = ' ';\n            prevMoreIndented = false;\n        }\n    }\n    switch (header.chomp) {\n        case '-':\n            break;\n        case '+':\n            for (let i = chompStart; i < lines.length; ++i)\n                value += '\\n' + lines[i][0].slice(trimIndent);\n            if (value[value.length - 1] !== '\\n')\n                value += '\\n';\n            break;\n        default:\n            value += '\\n';\n    }\n    const end = start + header.length + scalar.source.length;\n    return { value, type, comment: header.comment, range: [start, end, end] };\n}\nfunction parseBlockScalarHeader({ offset, props }, strict, onError) {\n    /* istanbul ignore if should not happen */\n    if (props[0].type !== 'block-scalar-header') {\n        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');\n        return null;\n    }\n    const { source } = props[0];\n    const mode = source[0];\n    let indent = 0;\n    let chomp = '';\n    let error = -1;\n    for (let i = 1; i < source.length; ++i) {\n        const ch = source[i];\n        if (!chomp && (ch === '-' || ch === '+'))\n            chomp = ch;\n        else {\n            const n = Number(ch);\n            if (!indent && n)\n                indent = n;\n            else if (error === -1)\n                error = offset + i;\n        }\n    }\n    if (error !== -1)\n        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);\n    let hasSpace = false;\n    let comment = '';\n    let length = source.length;\n    for (let i = 1; i < props.length; ++i) {\n        const token = props[i];\n        switch (token.type) {\n            case 'space':\n                hasSpace = true;\n            // fallthrough\n            case 'newline':\n                length += token.source.length;\n                break;\n            case 'comment':\n                if (strict && !hasSpace) {\n                    const message = 'Comments must be separated from other tokens by white space characters';\n                    onError(token, 'MISSING_CHAR', message);\n                }\n                length += token.source.length;\n                comment = token.source.substring(1);\n                break;\n            case 'error':\n                onError(token, 'UNEXPECTED_TOKEN', token.message);\n                length += token.source.length;\n                break;\n            /* istanbul ignore next should not happen */\n            default: {\n                const message = `Unexpected token in block scalar header: ${token.type}`;\n                onError(token, 'UNEXPECTED_TOKEN', message);\n                const ts = token.source;\n                if (ts && typeof ts === 'string')\n                    length += ts.length;\n            }\n        }\n    }\n    return { mode, indent, chomp, comment, length };\n}\n/** @returns Array of lines split up as `[indent, content]` */\nfunction splitLines(source) {\n    const split = source.split(/\\n( *)/);\n    const first = split[0];\n    const m = first.match(/^( *)/);\n    const line0 = m?.[1]\n        ? [m[1], first.slice(m[1].length)]\n        : ['', first];\n    const lines = [line0];\n    for (let i = 1; i < split.length; i += 2)\n        lines.push([split[i], split[i + 1]]);\n    return lines;\n}\n\nexport { resolveBlockScalar };\n","import { Scalar } from '../nodes/Scalar.js';\nimport { resolveEnd } from './resolve-end.js';\n\nfunction resolveFlowScalar(scalar, strict, onError) {\n    const { offset, type, source, end } = scalar;\n    let _type;\n    let value;\n    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);\n    switch (type) {\n        case 'scalar':\n            _type = Scalar.PLAIN;\n            value = plainValue(source, _onError);\n            break;\n        case 'single-quoted-scalar':\n            _type = Scalar.QUOTE_SINGLE;\n            value = singleQuotedValue(source, _onError);\n            break;\n        case 'double-quoted-scalar':\n            _type = Scalar.QUOTE_DOUBLE;\n            value = doubleQuotedValue(source, _onError);\n            break;\n        /* istanbul ignore next should not happen */\n        default:\n            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);\n            return {\n                value: '',\n                type: null,\n                comment: '',\n                range: [offset, offset + source.length, offset + source.length]\n            };\n    }\n    const valueEnd = offset + source.length;\n    const re = resolveEnd(end, valueEnd, strict, onError);\n    return {\n        value,\n        type: _type,\n        comment: re.comment,\n        range: [offset, valueEnd, re.offset]\n    };\n}\nfunction plainValue(source, onError) {\n    let badChar = '';\n    switch (source[0]) {\n        /* istanbul ignore next should not happen */\n        case '\\t':\n            badChar = 'a tab character';\n            break;\n        case ',':\n            badChar = 'flow indicator character ,';\n            break;\n        case '%':\n            badChar = 'directive indicator character %';\n            break;\n        case '|':\n        case '>': {\n            badChar = `block scalar indicator ${source[0]}`;\n            break;\n        }\n        case '@':\n        case '`': {\n            badChar = `reserved character ${source[0]}`;\n            break;\n        }\n    }\n    if (badChar)\n        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);\n    return foldLines(source);\n}\nfunction singleQuotedValue(source, onError) {\n    if (source[source.length - 1] !== \"'\" || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', \"Missing closing 'quote\");\n    return foldLines(source.slice(1, -1)).replace(/''/g, \"'\");\n}\nfunction foldLines(source) {\n    /**\n     * The negative lookbehind here and in the `re` RegExp is to\n     * prevent causing a polynomial search time in certain cases.\n     *\n     * The try-catch is for Safari, which doesn't support this yet:\n     * https://caniuse.com/js-regexp-lookbehind\n     */\n    let first, line;\n    try {\n        first = new RegExp('(.*?)(?<![ \\t])[ \\t]*\\r?\\n', 'sy');\n        line = new RegExp('[ \\t]*(.*?)(?:(?<![ \\t])[ \\t]*)?\\r?\\n', 'sy');\n    }\n    catch (_) {\n        first = /(.*?)[ \\t]*\\r?\\n/sy;\n        line = /[ \\t]*(.*?)[ \\t]*\\r?\\n/sy;\n    }\n    let match = first.exec(source);\n    if (!match)\n        return source;\n    let res = match[1];\n    let sep = ' ';\n    let pos = first.lastIndex;\n    line.lastIndex = pos;\n    while ((match = line.exec(source))) {\n        if (match[1] === '') {\n            if (sep === '\\n')\n                res += sep;\n            else\n                sep = '\\n';\n        }\n        else {\n            res += sep + match[1];\n            sep = ' ';\n        }\n        pos = line.lastIndex;\n    }\n    const last = /[ \\t]*(.*)/sy;\n    last.lastIndex = pos;\n    match = last.exec(source);\n    return res + sep + (match?.[1] ?? '');\n}\nfunction doubleQuotedValue(source, onError) {\n    let res = '';\n    for (let i = 1; i < source.length - 1; ++i) {\n        const ch = source[i];\n        if (ch === '\\r' && source[i + 1] === '\\n')\n            continue;\n        if (ch === '\\n') {\n            const { fold, offset } = foldNewline(source, i);\n            res += fold;\n            i = offset;\n        }\n        else if (ch === '\\\\') {\n            let next = source[++i];\n            const cc = escapeCodes[next];\n            if (cc)\n                res += cc;\n            else if (next === '\\n') {\n                // skip escaped newlines, but still trim the following line\n                next = source[i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === '\\r' && source[i + 1] === '\\n') {\n                // skip escaped CRLF newlines, but still trim the following line\n                next = source[++i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === 'x' || next === 'u' || next === 'U') {\n                const length = { x: 2, u: 4, U: 8 }[next];\n                res += parseCharCode(source, i + 1, length, onError);\n                i += length;\n            }\n            else {\n                const raw = source.substr(i - 1, 2);\n                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n                res += raw;\n            }\n        }\n        else if (ch === ' ' || ch === '\\t') {\n            // trim trailing whitespace\n            const wsStart = i;\n            let next = source[i + 1];\n            while (next === ' ' || next === '\\t')\n                next = source[++i + 1];\n            if (next !== '\\n' && !(next === '\\r' && source[i + 2] === '\\n'))\n                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;\n        }\n        else {\n            res += ch;\n        }\n    }\n    if (source[source.length - 1] !== '\"' || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', 'Missing closing \"quote');\n    return res;\n}\n/**\n * Fold a single newline into a space, multiple newlines to N - 1 newlines.\n * Presumes `source[offset] === '\\n'`\n */\nfunction foldNewline(source, offset) {\n    let fold = '';\n    let ch = source[offset + 1];\n    while (ch === ' ' || ch === '\\t' || ch === '\\n' || ch === '\\r') {\n        if (ch === '\\r' && source[offset + 2] !== '\\n')\n            break;\n        if (ch === '\\n')\n            fold += '\\n';\n        offset += 1;\n        ch = source[offset + 1];\n    }\n    if (!fold)\n        fold = ' ';\n    return { fold, offset };\n}\nconst escapeCodes = {\n    '0': '\\0',\n    a: '\\x07',\n    b: '\\b',\n    e: '\\x1b',\n    f: '\\f',\n    n: '\\n',\n    r: '\\r',\n    t: '\\t',\n    v: '\\v',\n    N: '\\u0085',\n    _: '\\u00a0',\n    L: '\\u2028',\n    P: '\\u2029',\n    ' ': ' ',\n    '\"': '\"',\n    '/': '/',\n    '\\\\': '\\\\',\n    '\\t': '\\t'\n};\nfunction parseCharCode(source, offset, length, onError) {\n    const cc = source.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n    if (isNaN(code)) {\n        const raw = source.substr(offset - 2, length + 2);\n        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n        return raw;\n    }\n    return String.fromCodePoint(code);\n}\n\nexport { resolveFlowScalar };\n","import { SCALAR, isScalar } from '../nodes/Node.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { resolveBlockScalar } from './resolve-block-scalar.js';\nimport { resolveFlowScalar } from './resolve-flow-scalar.js';\n\nfunction composeScalar(ctx, token, tagToken, onError) {\n    const { value, type, comment, range } = token.type === 'block-scalar'\n        ? resolveBlockScalar(token, ctx.options.strict, onError)\n        : resolveFlowScalar(token, ctx.options.strict, onError);\n    const tagName = tagToken\n        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))\n        : null;\n    const tag = tagToken && tagName\n        ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError)\n        : token.type === 'scalar'\n            ? findScalarTagByTest(ctx, value, token, onError)\n            : ctx.schema[SCALAR];\n    let scalar;\n    try {\n        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);\n        scalar = isScalar(res) ? res : new Scalar(res);\n    }\n    catch (error) {\n        const msg = error instanceof Error ? error.message : String(error);\n        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);\n        scalar = new Scalar(value);\n    }\n    scalar.range = range;\n    scalar.source = value;\n    if (type)\n        scalar.type = type;\n    if (tagName)\n        scalar.tag = tagName;\n    if (tag.format)\n        scalar.format = tag.format;\n    if (comment)\n        scalar.comment = comment;\n    return scalar;\n}\nfunction findScalarTagByName(schema, value, tagName, tagToken, onError) {\n    if (tagName === '!')\n        return schema[SCALAR]; // non-specific tag\n    const matchWithTest = [];\n    for (const tag of schema.tags) {\n        if (!tag.collection && tag.tag === tagName) {\n            if (tag.default && tag.test)\n                matchWithTest.push(tag);\n            else\n                return tag;\n        }\n    }\n    for (const tag of matchWithTest)\n        if (tag.test?.test(value))\n            return tag;\n    const kt = schema.knownTags[tagName];\n    if (kt && !kt.collection) {\n        // Ensure that the known tag is available for stringifying,\n        // but does not get used by default.\n        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));\n        return kt;\n    }\n    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');\n    return schema[SCALAR];\n}\nfunction findScalarTagByTest({ directives, schema }, value, token, onError) {\n    const tag = schema.tags.find(tag => tag.default && tag.test?.test(value)) || schema[SCALAR];\n    if (schema.compat) {\n        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??\n            schema[SCALAR];\n        if (tag.tag !== compat.tag) {\n            const ts = directives.tagString(tag.tag);\n            const cs = directives.tagString(compat.tag);\n            const msg = `Value may be parsed as either ${ts} or ${cs}`;\n            onError(token, 'TAG_RESOLVE_FAILED', msg, true);\n        }\n    }\n    return tag;\n}\n\nexport { composeScalar };\n","function emptyScalarPosition(offset, before, pos) {\n    if (before) {\n        if (pos === null)\n            pos = before.length;\n        for (let i = pos - 1; i >= 0; --i) {\n            let st = before[i];\n            switch (st.type) {\n                case 'space':\n                case 'comment':\n                case 'newline':\n                    offset -= st.source.length;\n                    continue;\n            }\n            // Technically, an empty scalar is immediately after the last non-empty\n            // node, but it's more useful to place it after any whitespace.\n            st = before[++i];\n            while (st?.type === 'space') {\n                offset += st.source.length;\n                st = before[++i];\n            }\n            break;\n        }\n    }\n    return offset;\n}\n\nexport { emptyScalarPosition };\n","import { Alias } from '../nodes/Alias.js';\nimport { composeCollection } from './compose-collection.js';\nimport { composeScalar } from './compose-scalar.js';\nimport { resolveEnd } from './resolve-end.js';\nimport { emptyScalarPosition } from './util-empty-scalar-position.js';\n\nconst CN = { composeNode, composeEmptyNode };\nfunction composeNode(ctx, token, props, onError) {\n    const { spaceBefore, comment, anchor, tag } = props;\n    let node;\n    let isSrcToken = true;\n    switch (token.type) {\n        case 'alias':\n            node = composeAlias(ctx, token, onError);\n            if (anchor || tag)\n                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');\n            break;\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'block-scalar':\n            node = composeScalar(ctx, token, tag, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        case 'block-map':\n        case 'block-seq':\n        case 'flow-collection':\n            node = composeCollection(CN, ctx, token, tag, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        default: {\n            const message = token.type === 'error'\n                ? token.message\n                : `Unsupported token (type: ${token.type})`;\n            onError(token, 'UNEXPECTED_TOKEN', message);\n            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);\n            isSrcToken = false;\n        }\n    }\n    if (anchor && node.anchor === '')\n        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        if (token.type === 'scalar' && token.source === '')\n            node.comment = comment;\n        else\n            node.commentBefore = comment;\n    }\n    // @ts-expect-error Type checking misses meaning of isSrcToken\n    if (ctx.options.keepSourceTokens && isSrcToken)\n        node.srcToken = token;\n    return node;\n}\nfunction composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag }, onError) {\n    const token = {\n        type: 'scalar',\n        offset: emptyScalarPosition(offset, before, pos),\n        indent: -1,\n        source: ''\n    };\n    const node = composeScalar(ctx, token, tag, onError);\n    if (anchor) {\n        node.anchor = anchor.source.substring(1);\n        if (node.anchor === '')\n            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    }\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment)\n        node.comment = comment;\n    return node;\n}\nfunction composeAlias({ options }, { offset, source, end }, onError) {\n    const alias = new Alias(source.substring(1));\n    if (alias.source === '')\n        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');\n    if (alias.source.endsWith(':'))\n        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);\n    const valueEnd = offset + source.length;\n    const re = resolveEnd(end, valueEnd, options.strict, onError);\n    alias.range = [offset, valueEnd, re.offset];\n    if (re.comment)\n        alias.comment = re.comment;\n    return alias;\n}\n\nexport { composeEmptyNode, composeNode };\n","import { Directives } from '../doc/directives.js';\nimport { Document } from '../doc/Document.js';\nimport { YAMLWarning, YAMLParseError } from '../errors.js';\nimport { isCollection, isPair } from '../nodes/Node.js';\nimport { composeDoc } from './compose-doc.js';\nimport { resolveEnd } from './resolve-end.js';\n\nfunction getErrorPos(src) {\n    if (typeof src === 'number')\n        return [src, src + 1];\n    if (Array.isArray(src))\n        return src.length === 2 ? src : [src[0], src[1]];\n    const { offset, source } = src;\n    return [offset, offset + (typeof source === 'string' ? source.length : 1)];\n}\nfunction parsePrelude(prelude) {\n    let comment = '';\n    let atComment = false;\n    let afterEmptyLine = false;\n    for (let i = 0; i < prelude.length; ++i) {\n        const source = prelude[i];\n        switch (source[0]) {\n            case '#':\n                comment +=\n                    (comment === '' ? '' : afterEmptyLine ? '\\n\\n' : '\\n') +\n                        (source.substring(1) || ' ');\n                atComment = true;\n                afterEmptyLine = false;\n                break;\n            case '%':\n                if (prelude[i + 1]?.[0] !== '#')\n                    i += 1;\n                atComment = false;\n                break;\n            default:\n                // This may be wrong after doc-end, but in that case it doesn't matter\n                if (!atComment)\n                    afterEmptyLine = true;\n                atComment = false;\n        }\n    }\n    return { comment, afterEmptyLine };\n}\n/**\n * Compose a stream of CST nodes into a stream of YAML Documents.\n *\n * ```ts\n * import { Composer, Parser } from 'yaml'\n *\n * const src: string = ...\n * const tokens = new Parser().parse(src)\n * const docs = new Composer().compose(tokens)\n * ```\n */\nclass Composer {\n    constructor(options = {}) {\n        this.doc = null;\n        this.atDirectives = false;\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n        this.onError = (source, code, message, warning) => {\n            const pos = getErrorPos(source);\n            if (warning)\n                this.warnings.push(new YAMLWarning(pos, code, message));\n            else\n                this.errors.push(new YAMLParseError(pos, code, message));\n        };\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        this.directives = new Directives({ version: options.version || '1.2' });\n        this.options = options;\n    }\n    decorate(doc, afterDoc) {\n        const { comment, afterEmptyLine } = parsePrelude(this.prelude);\n        //console.log({ dc: doc.comment, prelude, comment })\n        if (comment) {\n            const dc = doc.contents;\n            if (afterDoc) {\n                doc.comment = doc.comment ? `${doc.comment}\\n${comment}` : comment;\n            }\n            else if (afterEmptyLine || doc.directives.docStart || !dc) {\n                doc.commentBefore = comment;\n            }\n            else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {\n                let it = dc.items[0];\n                if (isPair(it))\n                    it = it.key;\n                const cb = it.commentBefore;\n                it.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n            else {\n                const cb = dc.commentBefore;\n                dc.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n        }\n        if (afterDoc) {\n            Array.prototype.push.apply(doc.errors, this.errors);\n            Array.prototype.push.apply(doc.warnings, this.warnings);\n        }\n        else {\n            doc.errors = this.errors;\n            doc.warnings = this.warnings;\n        }\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n    }\n    /**\n     * Current stream status information.\n     *\n     * Mostly useful at the end of input for an empty stream.\n     */\n    streamInfo() {\n        return {\n            comment: parsePrelude(this.prelude).comment,\n            directives: this.directives,\n            errors: this.errors,\n            warnings: this.warnings\n        };\n    }\n    /**\n     * Compose tokens into documents.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *compose(tokens, forceDoc = false, endOffset = -1) {\n        for (const token of tokens)\n            yield* this.next(token);\n        yield* this.end(forceDoc, endOffset);\n    }\n    /** Advance the composer by one CST token. */\n    *next(token) {\n        switch (token.type) {\n            case 'directive':\n                this.directives.add(token.source, (offset, message, warning) => {\n                    const pos = getErrorPos(token);\n                    pos[0] += offset;\n                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);\n                });\n                this.prelude.push(token.source);\n                this.atDirectives = true;\n                break;\n            case 'document': {\n                const doc = composeDoc(this.options, this.directives, token, this.onError);\n                if (this.atDirectives && !doc.directives.docStart)\n                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');\n                this.decorate(doc, false);\n                if (this.doc)\n                    yield this.doc;\n                this.doc = doc;\n                this.atDirectives = false;\n                break;\n            }\n            case 'byte-order-mark':\n            case 'space':\n                break;\n            case 'comment':\n            case 'newline':\n                this.prelude.push(token.source);\n                break;\n            case 'error': {\n                const msg = token.source\n                    ? `${token.message}: ${JSON.stringify(token.source)}`\n                    : token.message;\n                const error = new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);\n                if (this.atDirectives || !this.doc)\n                    this.errors.push(error);\n                else\n                    this.doc.errors.push(error);\n                break;\n            }\n            case 'doc-end': {\n                if (!this.doc) {\n                    const msg = 'Unexpected doc-end without preceding document';\n                    this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));\n                    break;\n                }\n                this.doc.directives.docEnd = true;\n                const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);\n                this.decorate(this.doc, true);\n                if (end.comment) {\n                    const dc = this.doc.comment;\n                    this.doc.comment = dc ? `${dc}\\n${end.comment}` : end.comment;\n                }\n                this.doc.range[2] = end.offset;\n                break;\n            }\n            default:\n                this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));\n        }\n    }\n    /**\n     * Call at end of input to yield any remaining document.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *end(forceDoc = false, endOffset = -1) {\n        if (this.doc) {\n            this.decorate(this.doc, true);\n            yield this.doc;\n            this.doc = null;\n        }\n        else if (forceDoc) {\n            const opts = Object.assign({ _directives: this.directives }, this.options);\n            const doc = new Document(undefined, opts);\n            if (this.atDirectives)\n                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');\n            doc.range = [0, endOffset, endOffset];\n            this.decorate(doc, false);\n            yield doc;\n        }\n    }\n}\n\nexport { Composer };\n","import { Document } from '../doc/Document.js';\nimport { composeNode, composeEmptyNode } from './compose-node.js';\nimport { resolveEnd } from './resolve-end.js';\nimport { resolveProps } from './resolve-props.js';\n\nfunction composeDoc(options, directives, { offset, start, value, end }, onError) {\n    const opts = Object.assign({ _directives: directives }, options);\n    const doc = new Document(undefined, opts);\n    const ctx = {\n        atRoot: true,\n        directives: doc.directives,\n        options: doc.options,\n        schema: doc.schema\n    };\n    const props = resolveProps(start, {\n        indicator: 'doc-start',\n        next: value ?? end?.[0],\n        offset,\n        onError,\n        startOnNewline: true\n    });\n    if (props.found) {\n        doc.directives.docStart = true;\n        if (value &&\n            (value.type === 'block-map' || value.type === 'block-seq') &&\n            !props.hasNewline)\n            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');\n    }\n    doc.contents = value\n        ? composeNode(ctx, value, props, onError)\n        : composeEmptyNode(ctx, props.end, start, null, props, onError);\n    const contentEnd = doc.contents.range[2];\n    const re = resolveEnd(end, contentEnd, false, onError);\n    if (re.comment)\n        doc.comment = re.comment;\n    doc.range = [offset, contentEnd, re.offset];\n    return doc;\n}\n\nexport { composeDoc };\n","import { resolveBlockScalar } from '../compose/resolve-block-scalar.js';\nimport { resolveFlowScalar } from '../compose/resolve-flow-scalar.js';\nimport { YAMLParseError } from '../errors.js';\nimport { stringifyString } from '../stringify/stringifyString.js';\n\nfunction resolveAsScalar(token, strict = true, onError) {\n    if (token) {\n        const _onError = (pos, code, message) => {\n            const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;\n            if (onError)\n                onError(offset, code, message);\n            else\n                throw new YAMLParseError([offset, offset + 1], code, message);\n        };\n        switch (token.type) {\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return resolveFlowScalar(token, strict, _onError);\n            case 'block-scalar':\n                return resolveBlockScalar(token, strict, _onError);\n        }\n    }\n    return null;\n}\n/**\n * Create a new scalar token with `value`\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.indent The indent level of the token.\n * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.\n * @param context.offset The offset position of the token.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction createScalarToken(value, context) {\n    const { implicitKey = false, indent, inFlow = false, offset = -1, type = 'PLAIN' } = context;\n    const source = stringifyString({ type, value }, {\n        implicitKey,\n        indent: indent > 0 ? ' '.repeat(indent) : '',\n        inFlow,\n        options: { blockQuote: true, lineWidth: -1 }\n    });\n    const end = context.end ?? [\n        { type: 'newline', offset: -1, indent, source: '\\n' }\n    ];\n    switch (source[0]) {\n        case '|':\n        case '>': {\n            const he = source.indexOf('\\n');\n            const head = source.substring(0, he);\n            const body = source.substring(he + 1) + '\\n';\n            const props = [\n                { type: 'block-scalar-header', offset, indent, source: head }\n            ];\n            if (!addEndtoBlockProps(props, end))\n                props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\n            return { type: 'block-scalar', offset, indent, props, source: body };\n        }\n        case '\"':\n            return { type: 'double-quoted-scalar', offset, indent, source, end };\n        case \"'\":\n            return { type: 'single-quoted-scalar', offset, indent, source, end };\n        default:\n            return { type: 'scalar', offset, indent, source, end };\n    }\n}\n/**\n * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.\n *\n * Best efforts are made to retain any comments previously associated with the `token`,\n * though all contents within a collection's `items` will be overwritten.\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.afterKey In most cases, values after a key should have an additional level of indentation.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction setScalarValue(token, value, context = {}) {\n    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;\n    let indent = 'indent' in token ? token.indent : null;\n    if (afterKey && typeof indent === 'number')\n        indent += 2;\n    if (!type)\n        switch (token.type) {\n            case 'single-quoted-scalar':\n                type = 'QUOTE_SINGLE';\n                break;\n            case 'double-quoted-scalar':\n                type = 'QUOTE_DOUBLE';\n                break;\n            case 'block-scalar': {\n                const header = token.props[0];\n                if (header.type !== 'block-scalar-header')\n                    throw new Error('Invalid block scalar header');\n                type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';\n                break;\n            }\n            default:\n                type = 'PLAIN';\n        }\n    const source = stringifyString({ type, value }, {\n        implicitKey: implicitKey || indent === null,\n        indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',\n        inFlow,\n        options: { blockQuote: true, lineWidth: -1 }\n    });\n    switch (source[0]) {\n        case '|':\n        case '>':\n            setBlockScalarValue(token, source);\n            break;\n        case '\"':\n            setFlowScalarValue(token, source, 'double-quoted-scalar');\n            break;\n        case \"'\":\n            setFlowScalarValue(token, source, 'single-quoted-scalar');\n            break;\n        default:\n            setFlowScalarValue(token, source, 'scalar');\n    }\n}\nfunction setBlockScalarValue(token, source) {\n    const he = source.indexOf('\\n');\n    const head = source.substring(0, he);\n    const body = source.substring(he + 1) + '\\n';\n    if (token.type === 'block-scalar') {\n        const header = token.props[0];\n        if (header.type !== 'block-scalar-header')\n            throw new Error('Invalid block scalar header');\n        header.source = head;\n        token.source = body;\n    }\n    else {\n        const { offset } = token;\n        const indent = 'indent' in token ? token.indent : -1;\n        const props = [\n            { type: 'block-scalar-header', offset, indent, source: head }\n        ];\n        if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined))\n            props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\n        for (const key of Object.keys(token))\n            if (key !== 'type' && key !== 'offset')\n                delete token[key];\n        Object.assign(token, { type: 'block-scalar', indent, props, source: body });\n    }\n}\n/** @returns `true` if last token is a newline */\nfunction addEndtoBlockProps(props, end) {\n    if (end)\n        for (const st of end)\n            switch (st.type) {\n                case 'space':\n                case 'comment':\n                    props.push(st);\n                    break;\n                case 'newline':\n                    props.push(st);\n                    return true;\n            }\n    return false;\n}\nfunction setFlowScalarValue(token, source, type) {\n    switch (token.type) {\n        case 'scalar':\n        case 'double-quoted-scalar':\n        case 'single-quoted-scalar':\n            token.type = type;\n            token.source = source;\n            break;\n        case 'block-scalar': {\n            const end = token.props.slice(1);\n            let oa = source.length;\n            if (token.props[0].type === 'block-scalar-header')\n                oa -= token.props[0].source.length;\n            for (const tok of end)\n                tok.offset += oa;\n            delete token.props;\n            Object.assign(token, { type, source, end });\n            break;\n        }\n        case 'block-map':\n        case 'block-seq': {\n            const offset = token.offset + source.length;\n            const nl = { type: 'newline', offset, indent: token.indent, source: '\\n' };\n            delete token.items;\n            Object.assign(token, { type, source, end: [nl] });\n            break;\n        }\n        default: {\n            const indent = 'indent' in token ? token.indent : -1;\n            const end = 'end' in token && Array.isArray(token.end)\n                ? token.end.filter(st => st.type === 'space' ||\n                    st.type === 'comment' ||\n                    st.type === 'newline')\n                : [];\n            for (const key of Object.keys(token))\n                if (key !== 'type' && key !== 'offset')\n                    delete token[key];\n            Object.assign(token, { type, indent, source, end });\n        }\n    }\n}\n\nexport { createScalarToken, resolveAsScalar, setScalarValue };\n","/**\n * Stringify a CST document, token, or collection item\n *\n * Fair warning: This applies no validation whatsoever, and\n * simply concatenates the sources in their logical order.\n */\nconst stringify = (cst) => 'type' in cst ? stringifyToken(cst) : stringifyItem(cst);\nfunction stringifyToken(token) {\n    switch (token.type) {\n        case 'block-scalar': {\n            let res = '';\n            for (const tok of token.props)\n                res += stringifyToken(tok);\n            return res + token.source;\n        }\n        case 'block-map':\n        case 'block-seq': {\n            let res = '';\n            for (const item of token.items)\n                res += stringifyItem(item);\n            return res;\n        }\n        case 'flow-collection': {\n            let res = token.start.source;\n            for (const item of token.items)\n                res += stringifyItem(item);\n            for (const st of token.end)\n                res += st.source;\n            return res;\n        }\n        case 'document': {\n            let res = stringifyItem(token);\n            if (token.end)\n                for (const st of token.end)\n                    res += st.source;\n            return res;\n        }\n        default: {\n            let res = token.source;\n            if ('end' in token && token.end)\n                for (const st of token.end)\n                    res += st.source;\n            return res;\n        }\n    }\n}\nfunction stringifyItem({ start, key, sep, value }) {\n    let res = '';\n    for (const st of start)\n        res += st.source;\n    if (key)\n        res += stringifyToken(key);\n    if (sep)\n        for (const st of sep)\n            res += st.source;\n    if (value)\n        res += stringifyToken(value);\n    return res;\n}\n\nexport { stringify };\n","const BREAK = Symbol('break visit');\nconst SKIP = Symbol('skip children');\nconst REMOVE = Symbol('remove item');\n/**\n * Apply a visitor to a CST document or item.\n *\n * Walks through the tree (depth-first) starting from the root, calling a\n * `visitor` function with two arguments when entering each item:\n *   - `item`: The current item, which included the following members:\n *     - `start: SourceToken[]` – Source tokens before the key or value,\n *       possibly including its anchor or tag.\n *     - `key?: Token | null` – Set for pair values. May then be `null`, if\n *       the key before the `:` separator is empty.\n *     - `sep?: SourceToken[]` – Source tokens between the key and the value,\n *       which should include the `:` map value indicator if `value` is set.\n *     - `value?: Token` – The value of a sequence item, or of a map pair.\n *   - `path`: The steps from the root to the current node, as an array of\n *     `['key' | 'value', number]` tuples.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this token, continue with\n *      next sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current item, then continue with the next one\n *   - `number`: Set the index of the next step. This is useful especially if\n *     the index of the current token has changed.\n *   - `function`: Define the next visitor for this item. After the original\n *     visitor is called on item entry, next visitors are called after handling\n *     a non-empty `key` and when exiting the item.\n */\nfunction visit(cst, visitor) {\n    if ('type' in cst && cst.type === 'document')\n        cst = { start: cst.start, value: cst.value };\n    _visit(Object.freeze([]), cst, visitor);\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisit.BREAK = BREAK;\n/** Do not visit the children of the current item */\nvisit.SKIP = SKIP;\n/** Remove the current item */\nvisit.REMOVE = REMOVE;\n/** Find the item at `path` from `cst` as the root */\nvisit.itemAtPath = (cst, path) => {\n    let item = cst;\n    for (const [field, index] of path) {\n        const tok = item?.[field];\n        if (tok && 'items' in tok) {\n            item = tok.items[index];\n        }\n        else\n            return undefined;\n    }\n    return item;\n};\n/**\n * Get the immediate parent collection of the item at `path` from `cst` as the root.\n *\n * Throws an error if the collection is not found, which should never happen if the item itself exists.\n */\nvisit.parentCollection = (cst, path) => {\n    const parent = visit.itemAtPath(cst, path.slice(0, -1));\n    const field = path[path.length - 1][0];\n    const coll = parent?.[field];\n    if (coll && 'items' in coll)\n        return coll;\n    throw new Error('Parent collection not found');\n};\nfunction _visit(path, item, visitor) {\n    let ctrl = visitor(item, path);\n    if (typeof ctrl === 'symbol')\n        return ctrl;\n    for (const field of ['key', 'value']) {\n        const token = item[field];\n        if (token && 'items' in token) {\n            for (let i = 0; i < token.items.length; ++i) {\n                const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    token.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n            if (typeof ctrl === 'function' && field === 'key')\n                ctrl = ctrl(item, path);\n        }\n    }\n    return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;\n}\n\nexport { visit };\n","export { createScalarToken, resolveAsScalar, setScalarValue } from './cst-scalar.js';\nexport { stringify } from './cst-stringify.js';\nexport { visit } from './cst-visit.js';\n\n/** The byte order mark */\nconst BOM = '\\u{FEFF}';\n/** Start of doc-mode */\nconst DOCUMENT = '\\x02'; // C0: Start of Text\n/** Unexpected end of flow-mode */\nconst FLOW_END = '\\x18'; // C0: Cancel\n/** Next token is a scalar value */\nconst SCALAR = '\\x1f'; // C0: Unit Separator\n/** @returns `true` if `token` is a flow or block collection */\nconst isCollection = (token) => !!token && 'items' in token;\n/** @returns `true` if `token` is a flow or block scalar; not an alias */\nconst isScalar = (token) => !!token &&\n    (token.type === 'scalar' ||\n        token.type === 'single-quoted-scalar' ||\n        token.type === 'double-quoted-scalar' ||\n        token.type === 'block-scalar');\n/* istanbul ignore next */\n/** Get a printable representation of a lexer token */\nfunction prettyToken(token) {\n    switch (token) {\n        case BOM:\n            return '<BOM>';\n        case DOCUMENT:\n            return '<DOC>';\n        case FLOW_END:\n            return '<FLOW_END>';\n        case SCALAR:\n            return '<SCALAR>';\n        default:\n            return JSON.stringify(token);\n    }\n}\n/** Identify the type of a lexer token. May return `null` for unknown tokens. */\nfunction tokenType(source) {\n    switch (source) {\n        case BOM:\n            return 'byte-order-mark';\n        case DOCUMENT:\n            return 'doc-mode';\n        case FLOW_END:\n            return 'flow-error-end';\n        case SCALAR:\n            return 'scalar';\n        case '---':\n            return 'doc-start';\n        case '...':\n            return 'doc-end';\n        case '':\n        case '\\n':\n        case '\\r\\n':\n            return 'newline';\n        case '-':\n            return 'seq-item-ind';\n        case '?':\n            return 'explicit-key-ind';\n        case ':':\n            return 'map-value-ind';\n        case '{':\n            return 'flow-map-start';\n        case '}':\n            return 'flow-map-end';\n        case '[':\n            return 'flow-seq-start';\n        case ']':\n            return 'flow-seq-end';\n        case ',':\n            return 'comma';\n    }\n    switch (source[0]) {\n        case ' ':\n        case '\\t':\n            return 'space';\n        case '#':\n            return 'comment';\n        case '%':\n            return 'directive-line';\n        case '*':\n            return 'alias';\n        case '&':\n            return 'anchor';\n        case '!':\n            return 'tag';\n        case \"'\":\n            return 'single-quoted-scalar';\n        case '\"':\n            return 'double-quoted-scalar';\n        case '|':\n        case '>':\n            return 'block-scalar-header';\n    }\n    return null;\n}\n\nexport { BOM, DOCUMENT, FLOW_END, SCALAR, isCollection, isScalar, prettyToken, tokenType };\n","import { BOM, DOCUMENT, FLOW_END, SCALAR } from './cst.js';\n\n/*\nSTART -> stream\n\nstream\n  directive -> line-end -> stream\n  indent + line-end -> stream\n  [else] -> line-start\n\nline-end\n  comment -> line-end\n  newline -> .\n  input-end -> END\n\nline-start\n  doc-start -> doc\n  doc-end -> stream\n  [else] -> indent -> block-start\n\nblock-start\n  seq-item-start -> block-start\n  explicit-key-start -> block-start\n  map-value-start -> block-start\n  [else] -> doc\n\ndoc\n  line-end -> line-start\n  spaces -> doc\n  anchor -> doc\n  tag -> doc\n  flow-start -> flow -> doc\n  flow-end -> error -> doc\n  seq-item-start -> error -> doc\n  explicit-key-start -> error -> doc\n  map-value-start -> doc\n  alias -> doc\n  quote-start -> quoted-scalar -> doc\n  block-scalar-header -> line-end -> block-scalar(min) -> line-start\n  [else] -> plain-scalar(false, min) -> doc\n\nflow\n  line-end -> flow\n  spaces -> flow\n  anchor -> flow\n  tag -> flow\n  flow-start -> flow -> flow\n  flow-end -> .\n  seq-item-start -> error -> flow\n  explicit-key-start -> flow\n  map-value-start -> flow\n  alias -> flow\n  quote-start -> quoted-scalar -> flow\n  comma -> flow\n  [else] -> plain-scalar(true, 0) -> flow\n\nquoted-scalar\n  quote-end -> .\n  [else] -> quoted-scalar\n\nblock-scalar(min)\n  newline + peek(indent < min) -> .\n  [else] -> block-scalar(min)\n\nplain-scalar(is-flow, min)\n  scalar-end(is-flow) -> .\n  peek(newline + (indent < min)) -> .\n  [else] -> plain-scalar(min)\n*/\nfunction isEmpty(ch) {\n    switch (ch) {\n        case undefined:\n        case ' ':\n        case '\\n':\n        case '\\r':\n        case '\\t':\n            return true;\n        default:\n            return false;\n    }\n}\nconst hexDigits = '0123456789ABCDEFabcdef'.split('');\nconst tagChars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()\".split('');\nconst invalidFlowScalarChars = ',[]{}'.split('');\nconst invalidAnchorChars = ' ,[]{}\\n\\r\\t'.split('');\nconst isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);\n/**\n * Splits an input string into lexical tokens, i.e. smaller strings that are\n * easily identifiable by `tokens.tokenType()`.\n *\n * Lexing starts always in a \"stream\" context. Incomplete input may be buffered\n * until a complete token can be emitted.\n *\n * In addition to slices of the original input, the following control characters\n * may also be emitted:\n *\n * - `\\x02` (Start of Text): A document starts with the next token\n * - `\\x18` (Cancel): Unexpected end of flow-mode (indicates an error)\n * - `\\x1f` (Unit Separator): Next token is a scalar value\n * - `\\u{FEFF}` (Byte order mark): Emitted separately outside documents\n */\nclass Lexer {\n    constructor() {\n        /**\n         * Flag indicating whether the end of the current buffer marks the end of\n         * all input\n         */\n        this.atEnd = false;\n        /**\n         * Explicit indent set in block scalar header, as an offset from the current\n         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not\n         * explicitly set.\n         */\n        this.blockScalarIndent = -1;\n        /**\n         * Block scalars that include a + (keep) chomping indicator in their header\n         * include trailing empty lines, which are otherwise excluded from the\n         * scalar's contents.\n         */\n        this.blockScalarKeep = false;\n        /** Current input */\n        this.buffer = '';\n        /**\n         * Flag noting whether the map value indicator : can immediately follow this\n         * node within a flow context.\n         */\n        this.flowKey = false;\n        /** Count of surrounding flow collection levels. */\n        this.flowLevel = 0;\n        /**\n         * Minimum level of indentation required for next lines to be parsed as a\n         * part of the current scalar value.\n         */\n        this.indentNext = 0;\n        /** Indentation level of the current line. */\n        this.indentValue = 0;\n        /** Position of the next \\n character. */\n        this.lineEndPos = null;\n        /** Stores the state of the lexer if reaching the end of incpomplete input */\n        this.next = null;\n        /** A pointer to `buffer`; the current position of the lexer. */\n        this.pos = 0;\n    }\n    /**\n     * Generate YAML tokens from the `source` string. If `incomplete`,\n     * a part of the last line may be left as a buffer for the next call.\n     *\n     * @returns A generator of lexical tokens\n     */\n    *lex(source, incomplete = false) {\n        if (source) {\n            this.buffer = this.buffer ? this.buffer + source : source;\n            this.lineEndPos = null;\n        }\n        this.atEnd = !incomplete;\n        let next = this.next ?? 'stream';\n        while (next && (incomplete || this.hasChars(1)))\n            next = yield* this.parseNext(next);\n    }\n    atLineEnd() {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (ch === ' ' || ch === '\\t')\n            ch = this.buffer[++i];\n        if (!ch || ch === '#' || ch === '\\n')\n            return true;\n        if (ch === '\\r')\n            return this.buffer[i + 1] === '\\n';\n        return false;\n    }\n    charAt(n) {\n        return this.buffer[this.pos + n];\n    }\n    continueScalar(offset) {\n        let ch = this.buffer[offset];\n        if (this.indentNext > 0) {\n            let indent = 0;\n            while (ch === ' ')\n                ch = this.buffer[++indent + offset];\n            if (ch === '\\r') {\n                const next = this.buffer[indent + offset + 1];\n                if (next === '\\n' || (!next && !this.atEnd))\n                    return offset + indent + 1;\n            }\n            return ch === '\\n' || indent >= this.indentNext || (!ch && !this.atEnd)\n                ? offset + indent\n                : -1;\n        }\n        if (ch === '-' || ch === '.') {\n            const dt = this.buffer.substr(offset, 3);\n            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))\n                return -1;\n        }\n        return offset;\n    }\n    getLine() {\n        let end = this.lineEndPos;\n        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {\n            end = this.buffer.indexOf('\\n', this.pos);\n            this.lineEndPos = end;\n        }\n        if (end === -1)\n            return this.atEnd ? this.buffer.substring(this.pos) : null;\n        if (this.buffer[end - 1] === '\\r')\n            end -= 1;\n        return this.buffer.substring(this.pos, end);\n    }\n    hasChars(n) {\n        return this.pos + n <= this.buffer.length;\n    }\n    setNext(state) {\n        this.buffer = this.buffer.substring(this.pos);\n        this.pos = 0;\n        this.lineEndPos = null;\n        this.next = state;\n        return null;\n    }\n    peek(n) {\n        return this.buffer.substr(this.pos, n);\n    }\n    *parseNext(next) {\n        switch (next) {\n            case 'stream':\n                return yield* this.parseStream();\n            case 'line-start':\n                return yield* this.parseLineStart();\n            case 'block-start':\n                return yield* this.parseBlockStart();\n            case 'doc':\n                return yield* this.parseDocument();\n            case 'flow':\n                return yield* this.parseFlowCollection();\n            case 'quoted-scalar':\n                return yield* this.parseQuotedScalar();\n            case 'block-scalar':\n                return yield* this.parseBlockScalar();\n            case 'plain-scalar':\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseStream() {\n        let line = this.getLine();\n        if (line === null)\n            return this.setNext('stream');\n        if (line[0] === BOM) {\n            yield* this.pushCount(1);\n            line = line.substring(1);\n        }\n        if (line[0] === '%') {\n            let dirEnd = line.length;\n            const cs = line.indexOf('#');\n            if (cs !== -1) {\n                const ch = line[cs - 1];\n                if (ch === ' ' || ch === '\\t')\n                    dirEnd = cs - 1;\n            }\n            while (true) {\n                const ch = line[dirEnd - 1];\n                if (ch === ' ' || ch === '\\t')\n                    dirEnd -= 1;\n                else\n                    break;\n            }\n            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));\n            yield* this.pushCount(line.length - n); // possible comment\n            this.pushNewline();\n            return 'stream';\n        }\n        if (this.atLineEnd()) {\n            const sp = yield* this.pushSpaces(true);\n            yield* this.pushCount(line.length - sp);\n            yield* this.pushNewline();\n            return 'stream';\n        }\n        yield DOCUMENT;\n        return yield* this.parseLineStart();\n    }\n    *parseLineStart() {\n        const ch = this.charAt(0);\n        if (!ch && !this.atEnd)\n            return this.setNext('line-start');\n        if (ch === '-' || ch === '.') {\n            if (!this.atEnd && !this.hasChars(4))\n                return this.setNext('line-start');\n            const s = this.peek(3);\n            if (s === '---' && isEmpty(this.charAt(3))) {\n                yield* this.pushCount(3);\n                this.indentValue = 0;\n                this.indentNext = 0;\n                return 'doc';\n            }\n            else if (s === '...' && isEmpty(this.charAt(3))) {\n                yield* this.pushCount(3);\n                return 'stream';\n            }\n        }\n        this.indentValue = yield* this.pushSpaces(false);\n        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))\n            this.indentNext = this.indentValue;\n        return yield* this.parseBlockStart();\n    }\n    *parseBlockStart() {\n        const [ch0, ch1] = this.peek(2);\n        if (!ch1 && !this.atEnd)\n            return this.setNext('block-start');\n        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {\n            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));\n            this.indentNext = this.indentValue + 1;\n            this.indentValue += n;\n            return yield* this.parseBlockStart();\n        }\n        return 'doc';\n    }\n    *parseDocument() {\n        yield* this.pushSpaces(true);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('doc');\n        let n = yield* this.pushIndicators();\n        switch (line[n]) {\n            case '#':\n                yield* this.pushCount(line.length - n);\n            // fallthrough\n            case undefined:\n                yield* this.pushNewline();\n                return yield* this.parseLineStart();\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel = 1;\n                return 'flow';\n            case '}':\n            case ']':\n                // this is an error\n                yield* this.pushCount(1);\n                return 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'doc';\n            case '\"':\n            case \"'\":\n                return yield* this.parseQuotedScalar();\n            case '|':\n            case '>':\n                n += yield* this.parseBlockScalarHeader();\n                n += yield* this.pushSpaces(true);\n                yield* this.pushCount(line.length - n);\n                yield* this.pushNewline();\n                return yield* this.parseBlockScalar();\n            default:\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseFlowCollection() {\n        let nl, sp;\n        let indent = -1;\n        do {\n            nl = yield* this.pushNewline();\n            if (nl > 0) {\n                sp = yield* this.pushSpaces(false);\n                this.indentValue = indent = sp;\n            }\n            else {\n                sp = 0;\n            }\n            sp += yield* this.pushSpaces(true);\n        } while (nl + sp > 0);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('flow');\n        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||\n            (indent === 0 &&\n                (line.startsWith('---') || line.startsWith('...')) &&\n                isEmpty(line[3]))) {\n            // Allowing for the terminal ] or } at the same (rather than greater)\n            // indent level as the initial [ or { is technically invalid, but\n            // failing here would be surprising to users.\n            const atFlowEndMarker = indent === this.indentNext - 1 &&\n                this.flowLevel === 1 &&\n                (line[0] === ']' || line[0] === '}');\n            if (!atFlowEndMarker) {\n                // this is an error\n                this.flowLevel = 0;\n                yield FLOW_END;\n                return yield* this.parseLineStart();\n            }\n        }\n        let n = 0;\n        while (line[n] === ',') {\n            n += yield* this.pushCount(1);\n            n += yield* this.pushSpaces(true);\n            this.flowKey = false;\n        }\n        n += yield* this.pushIndicators();\n        switch (line[n]) {\n            case undefined:\n                return 'flow';\n            case '#':\n                yield* this.pushCount(line.length - n);\n                return 'flow';\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel += 1;\n                return 'flow';\n            case '}':\n            case ']':\n                yield* this.pushCount(1);\n                this.flowKey = true;\n                this.flowLevel -= 1;\n                return this.flowLevel ? 'flow' : 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'flow';\n            case '\"':\n            case \"'\":\n                this.flowKey = true;\n                return yield* this.parseQuotedScalar();\n            case ':': {\n                const next = this.charAt(1);\n                if (this.flowKey || isEmpty(next) || next === ',') {\n                    this.flowKey = false;\n                    yield* this.pushCount(1);\n                    yield* this.pushSpaces(true);\n                    return 'flow';\n                }\n            }\n            // fallthrough\n            default:\n                this.flowKey = false;\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseQuotedScalar() {\n        const quote = this.charAt(0);\n        let end = this.buffer.indexOf(quote, this.pos + 1);\n        if (quote === \"'\") {\n            while (end !== -1 && this.buffer[end + 1] === \"'\")\n                end = this.buffer.indexOf(\"'\", end + 2);\n        }\n        else {\n            // double-quote\n            while (end !== -1) {\n                let n = 0;\n                while (this.buffer[end - 1 - n] === '\\\\')\n                    n += 1;\n                if (n % 2 === 0)\n                    break;\n                end = this.buffer.indexOf('\"', end + 1);\n            }\n        }\n        // Only looking for newlines within the quotes\n        const qb = this.buffer.substring(0, end);\n        let nl = qb.indexOf('\\n', this.pos);\n        if (nl !== -1) {\n            while (nl !== -1) {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = qb.indexOf('\\n', cs);\n            }\n            if (nl !== -1) {\n                // this is an error caused by an unexpected unindent\n                end = nl - (qb[nl - 1] === '\\r' ? 2 : 1);\n            }\n        }\n        if (end === -1) {\n            if (!this.atEnd)\n                return this.setNext('quoted-scalar');\n            end = this.buffer.length;\n        }\n        yield* this.pushToIndex(end + 1, false);\n        return this.flowLevel ? 'flow' : 'doc';\n    }\n    *parseBlockScalarHeader() {\n        this.blockScalarIndent = -1;\n        this.blockScalarKeep = false;\n        let i = this.pos;\n        while (true) {\n            const ch = this.buffer[++i];\n            if (ch === '+')\n                this.blockScalarKeep = true;\n            else if (ch > '0' && ch <= '9')\n                this.blockScalarIndent = Number(ch) - 1;\n            else if (ch !== '-')\n                break;\n        }\n        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');\n    }\n    *parseBlockScalar() {\n        let nl = this.pos - 1; // may be -1 if this.pos === 0\n        let indent = 0;\n        let ch;\n        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {\n            switch (ch) {\n                case ' ':\n                    indent += 1;\n                    break;\n                case '\\n':\n                    nl = i;\n                    indent = 0;\n                    break;\n                case '\\r': {\n                    const next = this.buffer[i + 1];\n                    if (!next && !this.atEnd)\n                        return this.setNext('block-scalar');\n                    if (next === '\\n')\n                        break;\n                } // fallthrough\n                default:\n                    break loop;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('block-scalar');\n        if (indent >= this.indentNext) {\n            if (this.blockScalarIndent === -1)\n                this.indentNext = indent;\n            else\n                this.indentNext += this.blockScalarIndent;\n            do {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = this.buffer.indexOf('\\n', cs);\n            } while (nl !== -1);\n            if (nl === -1) {\n                if (!this.atEnd)\n                    return this.setNext('block-scalar');\n                nl = this.buffer.length;\n            }\n        }\n        if (!this.blockScalarKeep) {\n            do {\n                let i = nl - 1;\n                let ch = this.buffer[i];\n                if (ch === '\\r')\n                    ch = this.buffer[--i];\n                const lastChar = i; // Drop the line if last char not more indented\n                while (ch === ' ' || ch === '\\t')\n                    ch = this.buffer[--i];\n                if (ch === '\\n' && i >= this.pos && i + 1 + indent > lastChar)\n                    nl = i;\n                else\n                    break;\n            } while (true);\n        }\n        yield SCALAR;\n        yield* this.pushToIndex(nl + 1, true);\n        return yield* this.parseLineStart();\n    }\n    *parsePlainScalar() {\n        const inFlow = this.flowLevel > 0;\n        let end = this.pos - 1;\n        let i = this.pos - 1;\n        let ch;\n        while ((ch = this.buffer[++i])) {\n            if (ch === ':') {\n                const next = this.buffer[i + 1];\n                if (isEmpty(next) || (inFlow && next === ','))\n                    break;\n                end = i;\n            }\n            else if (isEmpty(ch)) {\n                let next = this.buffer[i + 1];\n                if (ch === '\\r') {\n                    if (next === '\\n') {\n                        i += 1;\n                        ch = '\\n';\n                        next = this.buffer[i + 1];\n                    }\n                    else\n                        end = i;\n                }\n                if (next === '#' || (inFlow && invalidFlowScalarChars.includes(next)))\n                    break;\n                if (ch === '\\n') {\n                    const cs = this.continueScalar(i + 1);\n                    if (cs === -1)\n                        break;\n                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'\n                }\n            }\n            else {\n                if (inFlow && invalidFlowScalarChars.includes(ch))\n                    break;\n                end = i;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('plain-scalar');\n        yield SCALAR;\n        yield* this.pushToIndex(end + 1, true);\n        return inFlow ? 'flow' : 'doc';\n    }\n    *pushCount(n) {\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos += n;\n            return n;\n        }\n        return 0;\n    }\n    *pushToIndex(i, allowEmpty) {\n        const s = this.buffer.slice(this.pos, i);\n        if (s) {\n            yield s;\n            this.pos += s.length;\n            return s.length;\n        }\n        else if (allowEmpty)\n            yield '';\n        return 0;\n    }\n    *pushIndicators() {\n        switch (this.charAt(0)) {\n            case '!':\n                return ((yield* this.pushTag()) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '&':\n                return ((yield* this.pushUntil(isNotAnchorChar)) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '-': // this is an error\n            case '?': // this is an error outside flow collections\n            case ':': {\n                const inFlow = this.flowLevel > 0;\n                const ch1 = this.charAt(1);\n                if (isEmpty(ch1) || (inFlow && invalidFlowScalarChars.includes(ch1))) {\n                    if (!inFlow)\n                        this.indentNext = this.indentValue + 1;\n                    else if (this.flowKey)\n                        this.flowKey = false;\n                    return ((yield* this.pushCount(1)) +\n                        (yield* this.pushSpaces(true)) +\n                        (yield* this.pushIndicators()));\n                }\n            }\n        }\n        return 0;\n    }\n    *pushTag() {\n        if (this.charAt(1) === '<') {\n            let i = this.pos + 2;\n            let ch = this.buffer[i];\n            while (!isEmpty(ch) && ch !== '>')\n                ch = this.buffer[++i];\n            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);\n        }\n        else {\n            let i = this.pos + 1;\n            let ch = this.buffer[i];\n            while (ch) {\n                if (tagChars.includes(ch))\n                    ch = this.buffer[++i];\n                else if (ch === '%' &&\n                    hexDigits.includes(this.buffer[i + 1]) &&\n                    hexDigits.includes(this.buffer[i + 2])) {\n                    ch = this.buffer[(i += 3)];\n                }\n                else\n                    break;\n            }\n            return yield* this.pushToIndex(i, false);\n        }\n    }\n    *pushNewline() {\n        const ch = this.buffer[this.pos];\n        if (ch === '\\n')\n            return yield* this.pushCount(1);\n        else if (ch === '\\r' && this.charAt(1) === '\\n')\n            return yield* this.pushCount(2);\n        else\n            return 0;\n    }\n    *pushSpaces(allowTabs) {\n        let i = this.pos - 1;\n        let ch;\n        do {\n            ch = this.buffer[++i];\n        } while (ch === ' ' || (allowTabs && ch === '\\t'));\n        const n = i - this.pos;\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos = i;\n        }\n        return n;\n    }\n    *pushUntil(test) {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (!test(ch))\n            ch = this.buffer[++i];\n        return yield* this.pushToIndex(i, false);\n    }\n}\n\nexport { Lexer };\n","/**\n * Tracks newlines during parsing in order to provide an efficient API for\n * determining the one-indexed `{ line, col }` position for any offset\n * within the input.\n */\nclass LineCounter {\n    constructor() {\n        this.lineStarts = [];\n        /**\n         * Should be called in ascending order. Otherwise, call\n         * `lineCounter.lineStarts.sort()` before calling `linePos()`.\n         */\n        this.addNewLine = (offset) => this.lineStarts.push(offset);\n        /**\n         * Performs a binary search and returns the 1-indexed { line, col }\n         * position of `offset`. If `line === 0`, `addNewLine` has never been\n         * called or `offset` is before the first known newline.\n         */\n        this.linePos = (offset) => {\n            let low = 0;\n            let high = this.lineStarts.length;\n            while (low < high) {\n                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)\n                if (this.lineStarts[mid] < offset)\n                    low = mid + 1;\n                else\n                    high = mid;\n            }\n            if (this.lineStarts[low] === offset)\n                return { line: low + 1, col: 1 };\n            if (low === 0)\n                return { line: 0, col: offset };\n            const start = this.lineStarts[low - 1];\n            return { line: low, col: offset - start + 1 };\n        };\n    }\n}\n\nexport { LineCounter };\n","import { tokenType } from './cst.js';\nimport { Lexer } from './lexer.js';\n\nfunction includesToken(list, type) {\n    for (let i = 0; i < list.length; ++i)\n        if (list[i].type === type)\n            return true;\n    return false;\n}\nfunction findNonEmptyIndex(list) {\n    for (let i = 0; i < list.length; ++i) {\n        switch (list[i].type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                break;\n            default:\n                return i;\n        }\n    }\n    return -1;\n}\nfunction isFlowToken(token) {\n    switch (token?.type) {\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'flow-collection':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getPrevProps(parent) {\n    switch (parent.type) {\n        case 'document':\n            return parent.start;\n        case 'block-map': {\n            const it = parent.items[parent.items.length - 1];\n            return it.sep ?? it.start;\n        }\n        case 'block-seq':\n            return parent.items[parent.items.length - 1].start;\n        /* istanbul ignore next should not happen */\n        default:\n            return [];\n    }\n}\n/** Note: May modify input array */\nfunction getFirstKeyStartProps(prev) {\n    if (prev.length === 0)\n        return [];\n    let i = prev.length;\n    loop: while (--i >= 0) {\n        switch (prev[i].type) {\n            case 'doc-start':\n            case 'explicit-key-ind':\n            case 'map-value-ind':\n            case 'seq-item-ind':\n            case 'newline':\n                break loop;\n        }\n    }\n    while (prev[++i]?.type === 'space') {\n        /* loop */\n    }\n    return prev.splice(i, prev.length);\n}\nfunction fixFlowSeqItems(fc) {\n    if (fc.start.type === 'flow-seq-start') {\n        for (const it of fc.items) {\n            if (it.sep &&\n                !it.value &&\n                !includesToken(it.start, 'explicit-key-ind') &&\n                !includesToken(it.sep, 'map-value-ind')) {\n                if (it.key)\n                    it.value = it.key;\n                delete it.key;\n                if (isFlowToken(it.value)) {\n                    if (it.value.end)\n                        Array.prototype.push.apply(it.value.end, it.sep);\n                    else\n                        it.value.end = it.sep;\n                }\n                else\n                    Array.prototype.push.apply(it.start, it.sep);\n                delete it.sep;\n            }\n        }\n    }\n}\n/**\n * A YAML concrete syntax tree (CST) parser\n *\n * ```ts\n * const src: string = ...\n * for (const token of new Parser().parse(src)) {\n *   // token: Token\n * }\n * ```\n *\n * To use the parser with a user-provided lexer:\n *\n * ```ts\n * function* parse(source: string, lexer: Lexer) {\n *   const parser = new Parser()\n *   for (const lexeme of lexer.lex(source))\n *     yield* parser.next(lexeme)\n *   yield* parser.end()\n * }\n *\n * const src: string = ...\n * const lexer = new Lexer()\n * for (const token of parse(src, lexer)) {\n *   // token: Token\n * }\n * ```\n */\nclass Parser {\n    /**\n     * @param onNewLine - If defined, called separately with the start position of\n     *   each new line (in `parse()`, including the start of input).\n     */\n    constructor(onNewLine) {\n        /** If true, space and sequence indicators count as indentation */\n        this.atNewLine = true;\n        /** If true, next token is a scalar value */\n        this.atScalar = false;\n        /** Current indentation level */\n        this.indent = 0;\n        /** Current offset since the start of parsing */\n        this.offset = 0;\n        /** On the same line with a block map key */\n        this.onKeyLine = false;\n        /** Top indicates the node that's currently being built */\n        this.stack = [];\n        /** The source of the current token, set in parse() */\n        this.source = '';\n        /** The type of the current token, set in parse() */\n        this.type = '';\n        // Must be defined after `next()`\n        this.lexer = new Lexer();\n        this.onNewLine = onNewLine;\n    }\n    /**\n     * Parse `source` as a YAML stream.\n     * If `incomplete`, a part of the last line may be left as a buffer for the next call.\n     *\n     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.\n     *\n     * @returns A generator of tokens representing each directive, document, and other structure.\n     */\n    *parse(source, incomplete = false) {\n        if (this.onNewLine && this.offset === 0)\n            this.onNewLine(0);\n        for (const lexeme of this.lexer.lex(source, incomplete))\n            yield* this.next(lexeme);\n        if (!incomplete)\n            yield* this.end();\n    }\n    /**\n     * Advance the parser by the `source` of one lexical token.\n     */\n    *next(source) {\n        this.source = source;\n        if (this.atScalar) {\n            this.atScalar = false;\n            yield* this.step();\n            this.offset += source.length;\n            return;\n        }\n        const type = tokenType(source);\n        if (!type) {\n            const message = `Not a YAML token: ${source}`;\n            yield* this.pop({ type: 'error', offset: this.offset, message, source });\n            this.offset += source.length;\n        }\n        else if (type === 'scalar') {\n            this.atNewLine = false;\n            this.atScalar = true;\n            this.type = 'scalar';\n        }\n        else {\n            this.type = type;\n            yield* this.step();\n            switch (type) {\n                case 'newline':\n                    this.atNewLine = true;\n                    this.indent = 0;\n                    if (this.onNewLine)\n                        this.onNewLine(this.offset + source.length);\n                    break;\n                case 'space':\n                    if (this.atNewLine && source[0] === ' ')\n                        this.indent += source.length;\n                    break;\n                case 'explicit-key-ind':\n                case 'map-value-ind':\n                case 'seq-item-ind':\n                    if (this.atNewLine)\n                        this.indent += source.length;\n                    break;\n                case 'doc-mode':\n                case 'flow-error-end':\n                    return;\n                default:\n                    this.atNewLine = false;\n            }\n            this.offset += source.length;\n        }\n    }\n    /** Call at end of input to push out any remaining constructions */\n    *end() {\n        while (this.stack.length > 0)\n            yield* this.pop();\n    }\n    get sourceToken() {\n        const st = {\n            type: this.type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n        return st;\n    }\n    *step() {\n        const top = this.peek(1);\n        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {\n            while (this.stack.length > 0)\n                yield* this.pop();\n            this.stack.push({\n                type: 'doc-end',\n                offset: this.offset,\n                source: this.source\n            });\n            return;\n        }\n        if (!top)\n            return yield* this.stream();\n        switch (top.type) {\n            case 'document':\n                return yield* this.document(top);\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return yield* this.scalar(top);\n            case 'block-scalar':\n                return yield* this.blockScalar(top);\n            case 'block-map':\n                return yield* this.blockMap(top);\n            case 'block-seq':\n                return yield* this.blockSequence(top);\n            case 'flow-collection':\n                return yield* this.flowCollection(top);\n            case 'doc-end':\n                return yield* this.documentEnd(top);\n        }\n        /* istanbul ignore next should not happen */\n        yield* this.pop();\n    }\n    peek(n) {\n        return this.stack[this.stack.length - n];\n    }\n    *pop(error) {\n        const token = error ?? this.stack.pop();\n        /* istanbul ignore if should not happen */\n        if (!token) {\n            const message = 'Tried to pop an empty stack';\n            yield { type: 'error', offset: this.offset, source: '', message };\n        }\n        else if (this.stack.length === 0) {\n            yield token;\n        }\n        else {\n            const top = this.peek(1);\n            if (token.type === 'block-scalar') {\n                // Block scalars use their parent rather than header indent\n                token.indent = 'indent' in top ? top.indent : 0;\n            }\n            else if (token.type === 'flow-collection' && top.type === 'document') {\n                // Ignore all indent for top-level flow collections\n                token.indent = 0;\n            }\n            if (token.type === 'flow-collection')\n                fixFlowSeqItems(token);\n            switch (top.type) {\n                case 'document':\n                    top.value = token;\n                    break;\n                case 'block-scalar':\n                    top.props.push(token); // error\n                    break;\n                case 'block-map': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value) {\n                        top.items.push({ start: [], key: token, sep: [] });\n                        this.onKeyLine = true;\n                        return;\n                    }\n                    else if (it.sep) {\n                        it.value = token;\n                    }\n                    else {\n                        Object.assign(it, { key: token, sep: [] });\n                        this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');\n                        return;\n                    }\n                    break;\n                }\n                case 'block-seq': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value)\n                        top.items.push({ start: [], value: token });\n                    else\n                        it.value = token;\n                    break;\n                }\n                case 'flow-collection': {\n                    const it = top.items[top.items.length - 1];\n                    if (!it || it.value)\n                        top.items.push({ start: [], key: token, sep: [] });\n                    else if (it.sep)\n                        it.value = token;\n                    else\n                        Object.assign(it, { key: token, sep: [] });\n                    return;\n                }\n                /* istanbul ignore next should not happen */\n                default:\n                    yield* this.pop();\n                    yield* this.pop(token);\n            }\n            if ((top.type === 'document' ||\n                top.type === 'block-map' ||\n                top.type === 'block-seq') &&\n                (token.type === 'block-map' || token.type === 'block-seq')) {\n                const last = token.items[token.items.length - 1];\n                if (last &&\n                    !last.sep &&\n                    !last.value &&\n                    last.start.length > 0 &&\n                    findNonEmptyIndex(last.start) === -1 &&\n                    (token.indent === 0 ||\n                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {\n                    if (top.type === 'document')\n                        top.end = last.start;\n                    else\n                        top.items.push({ start: last.start });\n                    token.items.splice(-1, 1);\n                }\n            }\n        }\n    }\n    *stream() {\n        switch (this.type) {\n            case 'directive-line':\n                yield { type: 'directive', offset: this.offset, source: this.source };\n                return;\n            case 'byte-order-mark':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                yield this.sourceToken;\n                return;\n            case 'doc-mode':\n            case 'doc-start': {\n                const doc = {\n                    type: 'document',\n                    offset: this.offset,\n                    start: []\n                };\n                if (this.type === 'doc-start')\n                    doc.start.push(this.sourceToken);\n                this.stack.push(doc);\n                return;\n            }\n        }\n        yield {\n            type: 'error',\n            offset: this.offset,\n            message: `Unexpected ${this.type} token in YAML stream`,\n            source: this.source\n        };\n    }\n    *document(doc) {\n        if (doc.value)\n            return yield* this.lineEnd(doc);\n        switch (this.type) {\n            case 'doc-start': {\n                if (findNonEmptyIndex(doc.start) !== -1) {\n                    yield* this.pop();\n                    yield* this.step();\n                }\n                else\n                    doc.start.push(this.sourceToken);\n                return;\n            }\n            case 'anchor':\n            case 'tag':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                doc.start.push(this.sourceToken);\n                return;\n        }\n        const bv = this.startBlockValue(doc);\n        if (bv)\n            this.stack.push(bv);\n        else {\n            yield {\n                type: 'error',\n                offset: this.offset,\n                message: `Unexpected ${this.type} token in YAML document`,\n                source: this.source\n            };\n        }\n    }\n    *scalar(scalar) {\n        if (this.type === 'map-value-ind') {\n            const prev = getPrevProps(this.peek(2));\n            const start = getFirstKeyStartProps(prev);\n            let sep;\n            if (scalar.end) {\n                sep = scalar.end;\n                sep.push(this.sourceToken);\n                delete scalar.end;\n            }\n            else\n                sep = [this.sourceToken];\n            const map = {\n                type: 'block-map',\n                offset: scalar.offset,\n                indent: scalar.indent,\n                items: [{ start, key: scalar, sep }]\n            };\n            this.onKeyLine = true;\n            this.stack[this.stack.length - 1] = map;\n        }\n        else\n            yield* this.lineEnd(scalar);\n    }\n    *blockScalar(scalar) {\n        switch (this.type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                scalar.props.push(this.sourceToken);\n                return;\n            case 'scalar':\n                scalar.source = this.source;\n                // block-scalar source includes trailing newline\n                this.atNewLine = true;\n                this.indent = 0;\n                if (this.onNewLine) {\n                    let nl = this.source.indexOf('\\n') + 1;\n                    while (nl !== 0) {\n                        this.onNewLine(this.offset + nl);\n                        nl = this.source.indexOf('\\n', nl) + 1;\n                    }\n                }\n                yield* this.pop();\n                break;\n            /* istanbul ignore next should not happen */\n            default:\n                yield* this.pop();\n                yield* this.step();\n        }\n    }\n    *blockMap(map) {\n        const it = map.items[map.items.length - 1];\n        // it.sep is true-ish if pair already has key or : separator\n        switch (this.type) {\n            case 'newline':\n                this.onKeyLine = false;\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value) {\n                    map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    if (this.atIndentedComment(it.start, map.indent)) {\n                        const prev = map.items[map.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            map.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n        }\n        if (this.indent >= map.indent) {\n            const atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep;\n            // For empty nodes, assign newline-separated not indented empty tokens to following node\n            let start = [];\n            if (atNextItem && it.sep && !it.value) {\n                const nl = [];\n                for (let i = 0; i < it.sep.length; ++i) {\n                    const st = it.sep[i];\n                    switch (st.type) {\n                        case 'newline':\n                            nl.push(i);\n                            break;\n                        case 'space':\n                            break;\n                        case 'comment':\n                            if (st.indent > map.indent)\n                                nl.length = 0;\n                            break;\n                        default:\n                            nl.length = 0;\n                    }\n                }\n                if (nl.length >= 2)\n                    start = it.sep.splice(nl[1]);\n            }\n            switch (this.type) {\n                case 'anchor':\n                case 'tag':\n                    if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        it.sep.push(this.sourceToken);\n                    }\n                    else {\n                        it.start.push(this.sourceToken);\n                    }\n                    return;\n                case 'explicit-key-ind':\n                    if (!it.sep && !includesToken(it.start, 'explicit-key-ind')) {\n                        it.start.push(this.sourceToken);\n                    }\n                    else if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                    }\n                    else {\n                        this.stack.push({\n                            type: 'block-map',\n                            offset: this.offset,\n                            indent: this.indent,\n                            items: [{ start: [this.sourceToken] }]\n                        });\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'map-value-ind':\n                    if (includesToken(it.start, 'explicit-key-ind')) {\n                        if (!it.sep) {\n                            if (includesToken(it.start, 'newline')) {\n                                Object.assign(it, { key: null, sep: [this.sourceToken] });\n                            }\n                            else {\n                                const start = getFirstKeyStartProps(it.start);\n                                this.stack.push({\n                                    type: 'block-map',\n                                    offset: this.offset,\n                                    indent: this.indent,\n                                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                                });\n                            }\n                        }\n                        else if (it.value) {\n                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else if (isFlowToken(it.key) &&\n                            !includesToken(it.sep, 'newline')) {\n                            const start = getFirstKeyStartProps(it.start);\n                            const key = it.key;\n                            const sep = it.sep;\n                            sep.push(this.sourceToken);\n                            // @ts-expect-error type guard is wrong here\n                            delete it.key, delete it.sep;\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key, sep }]\n                            });\n                        }\n                        else if (start.length > 0) {\n                            // Not actually at next item\n                            it.sep = it.sep.concat(start, this.sourceToken);\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    else {\n                        if (!it.sep) {\n                            Object.assign(it, { key: null, sep: [this.sourceToken] });\n                        }\n                        else if (it.value || atNextItem) {\n                            map.items.push({ start, key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start: [], key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (atNextItem || it.value) {\n                        map.items.push({ start, key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        this.stack.push(fs);\n                    }\n                    else {\n                        Object.assign(it, { key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    return;\n                }\n                default: {\n                    const bv = this.startBlockValue(map);\n                    if (bv) {\n                        if (atNextItem &&\n                            bv.type !== 'block-seq' &&\n                            includesToken(it.start, 'explicit-key-ind')) {\n                            map.items.push({ start });\n                        }\n                        this.stack.push(bv);\n                        return;\n                    }\n                }\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *blockSequence(seq) {\n        const it = seq.items[seq.items.length - 1];\n        switch (this.type) {\n            case 'newline':\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        seq.items.push({ start: [this.sourceToken] });\n                }\n                else\n                    it.start.push(this.sourceToken);\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value)\n                    seq.items.push({ start: [this.sourceToken] });\n                else {\n                    if (this.atIndentedComment(it.start, seq.indent)) {\n                        const prev = seq.items[seq.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            seq.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'anchor':\n            case 'tag':\n                if (it.value || this.indent <= seq.indent)\n                    break;\n                it.start.push(this.sourceToken);\n                return;\n            case 'seq-item-ind':\n                if (this.indent !== seq.indent)\n                    break;\n                if (it.value || includesToken(it.start, 'seq-item-ind'))\n                    seq.items.push({ start: [this.sourceToken] });\n                else\n                    it.start.push(this.sourceToken);\n                return;\n        }\n        if (this.indent > seq.indent) {\n            const bv = this.startBlockValue(seq);\n            if (bv) {\n                this.stack.push(bv);\n                return;\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *flowCollection(fc) {\n        const it = fc.items[fc.items.length - 1];\n        if (this.type === 'flow-error-end') {\n            let top;\n            do {\n                yield* this.pop();\n                top = this.peek(1);\n            } while (top && top.type === 'flow-collection');\n        }\n        else if (fc.end.length === 0) {\n            switch (this.type) {\n                case 'comma':\n                case 'explicit-key-ind':\n                    if (!it || it.sep)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'map-value-ind':\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        Object.assign(it, { key: null, sep: [this.sourceToken] });\n                    return;\n                case 'space':\n                case 'comment':\n                case 'newline':\n                case 'anchor':\n                case 'tag':\n                    if (!it || it.value)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: fs, sep: [] });\n                    else if (it.sep)\n                        this.stack.push(fs);\n                    else\n                        Object.assign(it, { key: fs, sep: [] });\n                    return;\n                }\n                case 'flow-map-end':\n                case 'flow-seq-end':\n                    fc.end.push(this.sourceToken);\n                    return;\n            }\n            const bv = this.startBlockValue(fc);\n            /* istanbul ignore else should not happen */\n            if (bv)\n                this.stack.push(bv);\n            else {\n                yield* this.pop();\n                yield* this.step();\n            }\n        }\n        else {\n            const parent = this.peek(2);\n            if (parent.type === 'block-map' &&\n                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||\n                    (this.type === 'newline' &&\n                        !parent.items[parent.items.length - 1].sep))) {\n                yield* this.pop();\n                yield* this.step();\n            }\n            else if (this.type === 'map-value-ind' &&\n                parent.type !== 'flow-collection') {\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                fixFlowSeqItems(fc);\n                const sep = fc.end.splice(1, fc.end.length);\n                sep.push(this.sourceToken);\n                const map = {\n                    type: 'block-map',\n                    offset: fc.offset,\n                    indent: fc.indent,\n                    items: [{ start, key: fc, sep }]\n                };\n                this.onKeyLine = true;\n                this.stack[this.stack.length - 1] = map;\n            }\n            else {\n                yield* this.lineEnd(fc);\n            }\n        }\n    }\n    flowScalar(type) {\n        if (this.onNewLine) {\n            let nl = this.source.indexOf('\\n') + 1;\n            while (nl !== 0) {\n                this.onNewLine(this.offset + nl);\n                nl = this.source.indexOf('\\n', nl) + 1;\n            }\n        }\n        return {\n            type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n    }\n    startBlockValue(parent) {\n        switch (this.type) {\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return this.flowScalar(this.type);\n            case 'block-scalar-header':\n                return {\n                    type: 'block-scalar',\n                    offset: this.offset,\n                    indent: this.indent,\n                    props: [this.sourceToken],\n                    source: ''\n                };\n            case 'flow-map-start':\n            case 'flow-seq-start':\n                return {\n                    type: 'flow-collection',\n                    offset: this.offset,\n                    indent: this.indent,\n                    start: this.sourceToken,\n                    items: [],\n                    end: []\n                };\n            case 'seq-item-ind':\n                return {\n                    type: 'block-seq',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start: [this.sourceToken] }]\n                };\n            case 'explicit-key-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                start.push(this.sourceToken);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start }]\n                };\n            }\n            case 'map-value-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                };\n            }\n        }\n        return null;\n    }\n    atIndentedComment(start, indent) {\n        if (this.type !== 'comment')\n            return false;\n        if (this.indent <= indent)\n            return false;\n        return start.every(st => st.type === 'newline' || st.type === 'space');\n    }\n    *documentEnd(docEnd) {\n        if (this.type !== 'doc-mode') {\n            if (docEnd.end)\n                docEnd.end.push(this.sourceToken);\n            else\n                docEnd.end = [this.sourceToken];\n            if (this.type === 'newline')\n                yield* this.pop();\n        }\n    }\n    *lineEnd(token) {\n        switch (this.type) {\n            case 'comma':\n            case 'doc-start':\n            case 'doc-end':\n            case 'flow-seq-end':\n            case 'flow-map-end':\n            case 'map-value-ind':\n                yield* this.pop();\n                yield* this.step();\n                break;\n            case 'newline':\n                this.onKeyLine = false;\n            // fallthrough\n            case 'space':\n            case 'comment':\n            default:\n                // all other values are errors\n                if (token.end)\n                    token.end.push(this.sourceToken);\n                else\n                    token.end = [this.sourceToken];\n                if (this.type === 'newline')\n                    yield* this.pop();\n        }\n    }\n}\n\nexport { Parser };\n","import { Composer } from './compose/composer.js';\nimport { Document } from './doc/Document.js';\nimport { prettifyError, YAMLParseError } from './errors.js';\nimport { warn } from './log.js';\nimport { LineCounter } from './parse/line-counter.js';\nimport { Parser } from './parse/parser.js';\n\nfunction parseOptions(options) {\n    const prettyErrors = options.prettyErrors !== false;\n    const lineCounter = options.lineCounter || (prettyErrors && new LineCounter()) || null;\n    return { lineCounter, prettyErrors };\n}\n/**\n * Parse the input as a stream of YAML documents.\n *\n * Documents should be separated from each other by `...` or `---` marker lines.\n *\n * @returns If an empty `docs` array is returned, it will be of type\n *   EmptyStream and contain additional stream information. In\n *   TypeScript, you should use `'empty' in docs` as a type guard for it.\n */\nfunction parseAllDocuments(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser = new Parser(lineCounter?.addNewLine);\n    const composer = new Composer(options);\n    const docs = Array.from(composer.compose(parser.parse(source)));\n    if (prettyErrors && lineCounter)\n        for (const doc of docs) {\n            doc.errors.forEach(prettifyError(source, lineCounter));\n            doc.warnings.forEach(prettifyError(source, lineCounter));\n        }\n    if (docs.length > 0)\n        return docs;\n    return Object.assign([], { empty: true }, composer.streamInfo());\n}\n/** Parse an input string into a single YAML.Document */\nfunction parseDocument(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser = new Parser(lineCounter?.addNewLine);\n    const composer = new Composer(options);\n    // `doc` is always set by compose.end(true) at the very latest\n    let doc = null;\n    for (const _doc of composer.compose(parser.parse(source), true, source.length)) {\n        if (!doc)\n            doc = _doc;\n        else if (doc.options.logLevel !== 'silent') {\n            doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));\n            break;\n        }\n    }\n    if (prettyErrors && lineCounter) {\n        doc.errors.forEach(prettifyError(source, lineCounter));\n        doc.warnings.forEach(prettifyError(source, lineCounter));\n    }\n    return doc;\n}\nfunction parse(src, reviver, options) {\n    let _reviver = undefined;\n    if (typeof reviver === 'function') {\n        _reviver = reviver;\n    }\n    else if (options === undefined && reviver && typeof reviver === 'object') {\n        options = reviver;\n    }\n    const doc = parseDocument(src, options);\n    if (!doc)\n        return null;\n    doc.warnings.forEach(warning => warn(doc.options.logLevel, warning));\n    if (doc.errors.length > 0) {\n        if (doc.options.logLevel !== 'silent')\n            throw doc.errors[0];\n        else\n            doc.errors = [];\n    }\n    return doc.toJS(Object.assign({ reviver: _reviver }, options));\n}\nfunction stringify(value, replacer, options) {\n    let _replacer = null;\n    if (typeof replacer === 'function' || Array.isArray(replacer)) {\n        _replacer = replacer;\n    }\n    else if (options === undefined && replacer) {\n        options = replacer;\n    }\n    if (typeof options === 'string')\n        options = options.length;\n    if (typeof options === 'number') {\n        const indent = Math.round(options);\n        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };\n    }\n    if (value === undefined) {\n        const { keepUndefined } = options ?? replacer ?? {};\n        if (!keepUndefined)\n            return undefined;\n    }\n    return new Document(value, _replacer, options).toString(options);\n}\n\nexport { parse, parseAllDocuments, parseDocument, stringify };\n","// `export * as default from ...` fails on Webpack v4\n// https://github.com/eemeli/yaml/issues/228\nimport * as YAML from './dist/index.js'\nexport default YAML\nexport * from './dist/index.js'\n"],"names":["ALIAS","Symbol","for","DOC","MAP","PAIR","SCALAR","SEQ","NODE_TYPE","isAlias","node","isDocument","isMap","isPair","isScalar","isSeq","isCollection","isNode","NodeBase","constructor","type","Object","defineProperty","this","value","clone","copy","create","getPrototypeOf","getOwnPropertyDescriptors","range","slice","BREAK","SKIP","REMOVE","visit","visitor","visitor_","initVisitor","visit_","contents","freeze","key","path","ctrl","callVisitor","replaceNode","concat","i","items","length","ci","splice","ck","cv","async","visitAsync","visitAsync_","Collection","Node","Value","assign","Alias","Map","Scalar","Seq","Pair","parent","pt","Error","escapeChars","Directives","yaml","tags","docStart","docEnd","defaultYaml","defaultTags","atDocument","res","version","atNextDocument","explicit","add","line","onError","parts","trim","split","name","shift","handle","prefix","test","tagName","source","verbatim","suffix","match","decodeURIComponent","tagString","tag","entries","startsWith","substring","replace","ch","toString","doc","lines","tagEntries","tagNames","_key","keys","some","tn","push","join","anchorIsValid","anchor","sa","JSON","stringify","anchorNames","root","anchors","Set","findNewAnchor","exclude","has","super","set","resolve","found","toJSON","_arg","ctx","maxAliasCount","msg","ReferenceError","data","get","undefined","count","aliasCount","getAliasCount","_onComment","_onChompKeep","src","options","verifyAliasOrder","implicitKey","item","c","kc","vc","Math","max","toJS","arg","Array","isArray","map","v","String","onCreate","keep","Number","isScalarValue","BLOCK_FOLDED","BLOCK_LITERAL","PLAIN","QUOTE_DOUBLE","QUOTE_SINGLE","createNode","schema","Boolean","BigInt","valueOf","aliasDuplicateObjects","onAnchor","onTagObj","sourceObjects","ref","tagObj","filter","t","find","format","identify","findTagObject","iterator","collectionFromPath","k","isInteger","a","keepUndefined","isEmptyPath","next","done","configurable","enumerable","writable","it","addIn","rest","deleteIn","delete","getIn","keepScalar","hasAllNullValues","allowScalar","every","n","commentBefore","comment","hasIn","setIn","maxFlowStringSingleLineLength","stringifyComment","str","indentComment","indent","lineComment","endsWith","includes","FOLD_FLOW","FOLD_BLOCK","FOLD_QUOTED","foldFlowLines","text","mode","indentAtStart","lineWidth","minContentWidth","onFold","onOverflow","endStep","folds","escapedFolds","prev","end","overflow","escStart","escEnd","consumeMoreIndentedLines","j","fold","getFoldOptions","containsDocumentMarker","doubleQuotedString","json","doubleQuotedAsJSON","minMultiLineLength","doubleQuotedMinMultiLineLength","start","code","substr","singleQuotedString","singleQuote","quotedString","qs","hasDouble","hasSingle","blockString","onComment","onChompKeep","blockQuote","commentString","forceBlockIndent","literal","indentLength","limit","strLen","lineLengthOverLimit","chomp","endStart","endNlPos","indexOf","startEnd","startWithSpace","startNlPos","header","stringifyString","inFlow","ss","_stringify","_type","actualString","default","compat","plainString","defaultKeyType","defaultStringType","createStringifyContext","opt","directives","falseStr","indentSeq","nullStr","simpleKeys","trueStr","toStringOptions","collectionStyle","indentStep","repeat","resolvedAliases","TypeError","o","obj","nodeClass","getTagObject","props","stringifyProps","warn","logLevel","warning","process","emitWarning","console","addPairToJSMap","merge","isMergeKey","mergeToJSMap","jsKey","stringKey","strCtx","inStringifyKey","strKey","mapKeyWarned","jsonStr","stringifyKey","jsValue","srcMap","prototype","hasOwnProperty","call","createPair","_","mapAsMap","allNullValues","keyComment","explicitKey","keyCommentDone","chompKeep","vcb","valueComment","spaceBefore","flow","valueCommentDone","valueStr","ws","stringifyPair","stringifyCollection","collection","stringifyFlowCollection","stringifyBlockCollection","blockItemPrefix","flowChars","itemIndent","itemCtx","addCommentBefore","ik","reqNewline","linesAtValue","iv","reduce","sum","ic","trimStart","findPair","YAMLMap","pair","overwrite","_pair","sortEntries","sortMapEntries","findIndex","Type","replacer","sort","YAMLSeq","idx","asItemIndex","seq","string","nullTag","boolTag","stringifyNumber","minFractionDigits","num","isFinite","isNaN","d","floatNaN","toLowerCase","NaN","NEGATIVE_INFINITY","POSITIVE_INFINITY","floatExp","parseFloat","toExponential","dot","intIdentify","intResolve","offset","radix","intAsBigInt","parseInt","intStringify","intOct","_onError","intHex","stringifyJSON","binary","Uint8Array","Buffer","from","atob","buffer","charCodeAt","buf","btoa","s","fromCharCode","ceil","resolvePairs","cn","createPairs","iterable","pairs","YAMLOMap","bind","omap","seenKeys","boolStringify","trueTag","falseTag","f","sign","intBin","YAMLSet","keepPair","parseSexagesimal","asBigInt","p","stringifySexagesimal","_60","unshift","intTime","floatTime","timestamp","Date","RegExp","year","month","day","hour","minute","second","millisec","date","UTC","tz","abs","toISOString","schemas","tagsByName","bool","float","int","null","coreKnownTags","getTags","customTags","schemaName","sortMapEntriesByKey","b","Schema","resolveKnownTags","toStringDefaults","knownTags","applyReviver","reviver","val","len","v0","v1","Document","errors","warnings","_replacer","keepSourceTokens","prettyErrors","strict","uniqueKeys","_directives","setSchema","assertCollection","createAlias","keyToStr","asStr","anchorPrefix","setAnchors","aliasObjects","prevAnchors","error","createNodeAnchors","sv","jsonArg","values","hasDirectives","dir","cs","contentComment","body","dc","stringifyDocument","YAMLError","pos","message","YAMLParseError","YAMLWarning","prettifyError","lc","linePos","col","lineStr","lineStarts","min","pointer","resolveProps","tokens","indicator","startOnNewline","atNewline","hasSpace","commentSep","hasNewline","hasNewlineAfterProp","reqSpace","comma","token","cb","last","containsNewline","st","sep","flowIndentCheck","fc","mapIncludes","search","isEqual","startColMsg","resolveEnd","blockMsg","isBlock","composeCollection","CN","tagToken","coll","composeNode","composeEmptyNode","bm","atRoot","collItem","keyProps","keyStart","keyNode","valueProps","valueNode","srcToken","resolveBlockMap","bs","resolveBlockSeq","fcName","prevItemComment","loop","expectedEnd","ce","ee","cePos","toUpperCase","resolveFlowCollection","Coll","expType","kt","resolveBlockScalar","scalar","ts","parseBlockScalarHeader","first","m","splitLines","chompStart","content","trimIndent","contentStart","prevMoreIndented","crlf","resolveFlowScalar","rel","badChar","foldLines","plainValue","singleQuotedValue","foldNewline","cc","escapeCodes","x","u","U","parseCharCode","raw","wsStart","doubleQuotedValue","valueEnd","re","exec","lastIndex","e","r","N","L","P","fromCodePoint","composeScalar","matchWithTest","findScalarTagByName","findScalarTagByTest","emptyScalarPosition","before","isSrcToken","alias","composeAlias","getErrorPos","parsePrelude","prelude","atComment","afterEmptyLine","Composer","atDirectives","decorate","afterDoc","apply","streamInfo","forceDoc","endOffset","opts","contentEnd","composeDoc","resolveAsScalar","createScalarToken","context","he","head","addEndtoBlockProps","setScalarValue","afterKey","setBlockScalarValue","setFlowScalarValue","oa","tok","nl","cst","stringifyToken","stringifyItem","_visit","field","itemAtPath","index","parentCollection","BOM","DOCUMENT","FLOW_END","prettyToken","tokenType","isEmpty","hexDigits","tagChars","invalidFlowScalarChars","invalidAnchorChars","isNotAnchorChar","Lexer","atEnd","blockScalarIndent","blockScalarKeep","flowKey","flowLevel","indentNext","indentValue","lineEndPos","incomplete","hasChars","parseNext","atLineEnd","charAt","continueScalar","dt","getLine","setNext","state","peek","parseStream","parseLineStart","parseBlockStart","parseDocument","parseFlowCollection","parseQuotedScalar","parseBlockScalar","parsePlainScalar","pushCount","dirEnd","pushSpaces","pushNewline","sp","ch0","ch1","pushIndicators","pushUntil","quote","qb","pushToIndex","lastChar","allowEmpty","pushTag","allowTabs","LineCounter","addNewLine","low","high","mid","includesToken","list","findNonEmptyIndex","isFlowToken","getPrevProps","getFirstKeyStartProps","fixFlowSeqItems","Parser","onNewLine","atNewLine","atScalar","onKeyLine","stack","lexer","lexeme","lex","step","pop","sourceToken","top","stream","document","blockScalar","blockMap","blockSequence","flowCollection","documentEnd","lineEnd","bv","startBlockValue","atIndentedComment","atNextItem","fs","flowScalar","parseOptions","lineCounter","parseAllDocuments","parser","composer","docs","compose","parse","forEach","empty","_doc","_reviver","round"],"sourceRoot":""}